//*********************************************************************************************************************************
//
// PROJECT:							Astronomy Class Library
// FILE:								CAstroFile
// SUBSYSTEM:						Astronomical File Classes
// LANGUAGE:						C++
// TARGET OS:						None.
// LIBRARY DEPENDANCE:	SCL, CFitsIO, boost, LibRaw.
// NAMESPACE:						ACL
// AUTHOR:							Gavin Blakeman (GGB)
// LICENSE:             GPLv2
//
//                      Copyright 2011-2018 Gavin Blakeman.
//                      This file is part of the Astronomy Class Library (ACL)
//
//                      ACL is free software: you can redistribute it and/or modify it under the terms of the GNU General
//                      Public License as published by the Free Software Foundation, either version 2 of the License, or
//                      (at your option) any later version.
//
//                      ACL is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
//                      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//                      for more details.
//
//                      You should have received a copy of the GNU General Public License along with ACL.  If not,
//                      see <http://www.gnu.org/licenses/>.
//
// OVERVIEW:						A number of classes supporting file IO of astronomical data including images.
//											The classes are designed to present a single interface to the other astro library
//											classes while supporting several different file types.
//
//											File types supported are: FITS
//																								SBIG image files
//                      The CAstroFile class is modelled around the FITS file format and is designed to work seamlessly with FITS
//                      files. While opening other types of files is supported, some information will be created on the fly.
//                      To ensure that all information generated by image manipulation is saved correctly, the information must
//                      be saved in the FITS format. Information will be lost if it is saved in any other format.
//
//                      The CAstroFile class also provides some observation management functionality as there are keywords that
//                      are automatically linked to observation information.
//
// CLASSES INCLUDED:		CAstroFile      - Base class for for accessing and using FITS files.
//
// CLASS HIERARCHY:     CAstroFile
//                        - CSBIGAstroFile
//                        - CRAWAstroFile
//
// HISTORY:             2017-07-24/GGB - Removed factory function and class hierarchy. Included in CAstroFile.
//                      2015-09-22 GGB - astroManager 2015.09 release
//                      2015-08-09/GGB - Moved classes for SBIG and RAW into seperate files.
//                      2013-09-30 GGB - astroManager 2013.09 release.
//                      2013-03-22 GGB - astroManager 2013.03 release.
//                      2013-01-20 GGB - astroManager 0000.00 release.
//                      2011-12-10 GGB - Removed HDB classes into seperate file HDB.h
//                      2011-06-04 GGB - Development of classes for astroManager
//
//*********************************************************************************************************************************

#include "../include/AstroFile.h"

  // Standard C++ Library header files.

#include <tuple>

  // ACL Library header files.

#include "../include/AstroFunctions.h"
#include "../include/FITSException.h"
#include "../include/FITSKeyword.h"
#include "../include/FITSKeywordDateTime.h"
#include "../include/FITSKeywordDouble.h"
#include "../include/FITSKeywordString.h"
#include "../include/FITSKeywordInt16.h"
#include "../include/FITSKeywordInt32.h"
#include "../include/FITSUtilities.h"
#include "../include/HDB.h"
#include "../include/HDBPrimary.h"

  // Miscellaneous library header files.

#include <boost/algorithm/string.hpp>
#include "csbigimg.h"
#include <GCL>

namespace ACL
{
  std::vector<SHDBRegister> CAstroFile::HDBRegister;      // All registered HDB types.

  //*******************************************************************************************************************************
  //
  // class CAstroFile
  //
  //*******************************************************************************************************************************

  /// @brief Constructor for the class.
  /// @throws std::bad_alloc
  /// @version 2018-09-05/GGB - Changed targetCoordinates(CAstronomicalCoordinates) to observationTarget(CTargetAstronomy)
  /// @version 2017-08-10/GGB - Remove requirement for filename.
  /// @version 2016-04-02/GGB - Added keywordCount members.
  /// @version 2016-03-31/GGB - Added creation of the TLocation object to the constructor.
  /// @version 2011-05-03/GGB - Function created.

  CAstroFile::CAstroFile() : imageName_(), HDB(), astrometryHDB_(), photometryHDB_(), observationLocation(new CObservatory()),
    observationWeather(), observationTime(), observationTarget(),
    observationTelescope(new CTelescope), bDirty(false), bHasData(false)
  {
  }

  /// @brief Constructor for the class.
  /// @param[in] imageName: Image Name to associate with the class.
  /// @throws std::bad_alloc
  /// @version 2018-09-05/GGB - Changed targetCoordinates(CAstronomicalCoordinates) to observationTarget(CTargetAstronomy)
  /// @version 2017-08-10/GGB - Remove requirement for filename.
  /// @version 2016-04-02/GGB - Added keywordCount members.
  /// @version 2016-03-31/GGB - Added creation of the TLocation object to the constructor.
  /// @version 2011-05-03/GGB - Function created.

  CAstroFile::CAstroFile(std::string const &imageName) : imageName_(imageName), HDB(), astrometryHDB_(), photometryHDB_(),
    observationLocation(new CObservatory()), observationWeather(), observationTime(),
    observationTarget(), observationTelescope(new CTelescope), bDirty(false), bHasData(false)
  {
  }

  /// @brief Copy constructor.
  /// @param[in] toCopy: The Astrofile object to make a copy of.
  /// @throws std::bad_alloc
  /// @note 1. On a large file, (multi-megabyte), this process could take a long-time.
  /// @note 2. This function is not multi-threaded.
  /// @details This function copies the class. This is done by copying all the stored information and then calling each HDB in turn
  ///          to perform it's own copy.
  /// @version 2018-09-05/GGB - Changed targetCoordinates(CAstronomicalCoordinates) to observationTarget(CTargetAstronomy)
  /// @version 2017-08-10/GGB - Remove requirement for filename.
  /// @version 2016-04-02/GGB - Added keywordCount members.
  /// @version 2013-06-07/GGB - Updated to reflect changes to class.
  /// @version 2011-05-13/GGB - Function created.

  CAstroFile::CAstroFile(CAstroFile const &toCopy) : astrometryHDB_(), photometryHDB_(), imageName_(toCopy.imageName_),
    observationLocation(toCopy.observationLocation->createCopy()), observationWeather(),
    observationTime(new CAstroTime(*toCopy.observationTime)),
    observationTarget((toCopy.observationTarget) ? toCopy.observationTarget->createCopy() : nullptr),
    observationTelescope(toCopy.observationTelescope->createCopy()), HDB(), bDirty(false), bHasData(toCopy.bHasData)
  {
    DHDBStore::const_iterator hdbIterator;

    for (hdbIterator = toCopy.HDB.begin(); hdbIterator != toCopy.HDB.end(); ++hdbIterator)
    {
      HDB.push_back((*hdbIterator)->createCopy());

      if (HDB.back()->HDBType() == HDB_ASTROMETRY)
      {
        astrometryHDB_ = dynamic_cast<CHDBAstrometry *>(HDB.back().get());
      }
      else if (HDB.back()->HDBType() == HDB_PHOTOMETRY)
      {
        photometryHDB_ = dynamic_cast<CHDBPhotometry *>(HDB.back().get());
      };
    };

    if (toCopy.observationWeather)
    {
      observationWeather.reset(new CWeather(*toCopy.observationWeather));
    };
  }

  /// @brief Constructor to create an instance from an astroImage.
  /// @param[in] ai: pointer to the astroimage to create the astrofile from.
  /// @throws None.
  /// @todo Implement this function.
  /// @version 2018-09-05/GGB - Changed targetCoordinates(CAstronomicalCoordinates) to observationTarget(CTargetAstronomy)
  /// @version 2017-08-10/GGB - Remove requirement for filename.
  /// @version 2016-04-02/GGB - Added keywordCount members.
  /// @version 2016-03-31/GGB - Added creation of the TLocation object to the constructor.
  /// @version 2011-05-13/GGB - Function created.

  CAstroFile::CAstroFile(CAstroImage *ai): HDB(),
    bHasData(true), bDirty(false), observationLocation(new CObservatory()), observationWeather(), observationTime()
  {
    /*CHDB *newHDB = new CHDB();

#if defined(FITSBASE_FLOAT)
    newHDB->bitpix = BP_FLOAT;
#else
    newHDB->bitpix = BP_DOUBLE;
#endif
    if (ai->isMonoImage())
    {
      newHDB->naxis = 2;
      newHDB->naxisn.push_back(ai->getX());
      newHDB->naxisn.push_back(ai->getY());
    }
    else if (ai->isPolyImage())
    {
      newHDB->naxis = 3;
      newHDB->naxisn.push_back(ai->getX());
      newHDB->naxisn.push_back(ai->getY());
    }
    else
      ACL_CODE_ERROR;

    newHDB->data = ai;
    HDB.push_back(*newHDB);

    hasData(true);
    isDirty(true);*/
  }

  /// @brief Class destructor. Ensure all dynamically allocated memory is destroyed correctly.
  /// @throws None.
  /// @version 2011-12-11/GGB - Converted to use smart pointers for the HDB entries.
  /// @version 2011-03-17/GGB - Function created.

  CAstroFile::~CAstroFile()
  {
  }

  /// @brief Returns the number of astrometry objects currently in the astrometryHDB.
  /// @returns The number of astrometry objects identified in the file.
  /// @returns 0 if there is no astrometry HDB.
  /// @throws None.
  /// @version 2013-08-03/GGB - Function created.

  size_t CAstroFile::astrometryObjectCount() const
  {
    if (astrometryHDB_)
    {
      return astrometryHDB_->astrometryObjectCount();
    }
    else
    {
      return 0;     // No HDB implies no objects.
    };
  }

  /// @brief Removes all the items from the astrometry list.
  /// @throws None.
  /// @version 2013-06-18/GGB - Function created.

  void CAstroFile::astrometryObjectRemoveAll()
  {
    if (astrometryHDB_)
    {
      isDirty(true);
      astrometryHDB_->astrometryObjectRemoveAll();
    };
  }

  /// @brief Adds a comment to the list of comments.
  /// @param[in] hdb: The number of the hdb that the comment must be written to. (0 base)
  /// @param[in] comment: The comment to be written to the HDB.
  /// @post isDirty == true
  /// @post hasData == true
  /// @throws GCL::CRuntimeAssert
  /// @details The comment is added to the FITS file as a COMMENT.
  /// @version 2015-08-08/GGB - Runtime assertion for hdb against HDB vector size.
  /// @version 2015-07-30/GGB - Runtime assertion that comment string is not empty. (Bug 8)
  /// @version 2011-12-04/GGB - Convert to smart pointer and smart HDB, reverse order of arguments.
  /// @version 2011-03-17/GGB - Function created.

  void CAstroFile::commentWrite(size_t hdb, const std::string &comment)
  {
    RUNTIME_ASSERT(ACL, !comment.empty(), "The comment parameter cannot be empty");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.")

    HDB[hdb]->commentWrite(comment);
    isDirty(true);
    hasData(true);
  }

  /// @brief Copies the keywords from an HDB in an astroFile to an HDB in another astrofile.
  /// @param[in] reference: The astrofile instance to copy the HDB from.
  /// @param[in] hdb: The HDB number to copy. The same HDB is copied from and to.
  /// @throws 0x2001 - Invalid HDB
  /// @note If the HDB does not exist in @a this instance, then it will be created.
  /// @todo It may be worth further generalising this function to allow keywords to be copied within the astrofile as well.
  /// @version 2019-08-22/GGB - Updated to use std::unique_ptr idiom.
  /// @version 2014-05-31/GGB - Function created

  void CAstroFile::copyKeywords(CAstroFile const &reference, DHDBStore::size_type hdb)
  {
    if ( hdb >= reference.HDB.size() )
    {
      ERROR(ACL, 0x2001);    // Invalid HDB number
    }
    else
    {
      if ( hdb >= HDB.size() )
      {
        HDBAdd(reference.getHDB(hdb)->createCopy());
      }
      else
      {
        HDB[hdb]->copyKeywords(reference.HDB[hdb].get());
      };
    };
  }

  /// @brief Creates a copy of this astroFile.
  /// @returns A unique pointer to the newly created copy.
  /// @throws None.
  /// @details Simply creates a new copy by calling the copy constructor.
  /// @version 2018-09-05/GGB - Changed return value to a unique_ptr.
  /// @version 2013-06-07/GGB - Function created.

  std::unique_ptr<CAstroFile> CAstroFile::createCopy() const
  {
    return std::make_unique<CAstroFile>(*this);
  }

  /// @brief Copies the HDB and adds it as an HDB to the list of HDB in this object
  /// @param[in] toAdd: Smart pointer to the HDB to add.
  /// @throws None.
  /// @post 1. isDirty == true
  /// @post 2. hasData == true
  /// @post 3. Ownership of toAdd passess to (*this).
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-06-23/GGB - Added code to make the instance dirty and that it has data.
  /// @version 2011-11-27/GGB - Changed to use smart pointers (boost::shared_ptr)
  /// @version 2011-05-27/GGB - Function created.

  void CAstroFile::HDBAdd(std::unique_ptr<CHDB> toAdd)
  {
    RUNTIME_ASSERT(ACL, toAdd != nullptr, "HDB to add cannot be a nullptr.")

    HDB.push_back(std::move(toAdd));
    isDirty(true);
    hasData(true);
  }

  /// @brief Passthrough to the astrometryHDB to check if the requisites are met.
  /// @returns
  /// @throws 0x200C - ASTROFILE: Astrometry HDB does not exist.
  /// @version 2012-01-13/GGB - Function created.

  bool CAstroFile::astrometryCheckRequisites() const
  {
    if (astrometryHDB_)
    {
      return astrometryHDB_->astrometryCheckRequisites();
    }
    else
    {
      ERROR(ACL, 0x200C);    // ASTROFILE: Astrometry HDB does not exist.
    };
  }

  /// @brief Adds a reference to the astrometry HDB.
  /// @param[in] toAdd: The astrometry reference to add.
  /// @returns true - Object added
  /// @returns false - Object not added
  /// @throws None.
  /// @post If return value == true, isDirty = true; hasData = true.
  /// @details A reference object is one that is used to determine the plate constants.
  /// @version 2013-08-30/GGB - Changed logic flow to only update isDirty() and hasData() when required.
  /// @version 2013-04-08/GGB - Added isDirty(true)
  /// @version 2011-12-11/GGB - Function created.

  bool CAstroFile::astrometryObjectAdd(std::shared_ptr<CAstrometryObservation> toAdd)
  {
    if (!astrometryHDB_)
    {
      createAstrometryHDB();
      isDirty(true);
      hasData(true);
    };

    bool returnValue = astrometryHDB_->astrometryObjectAdd(std::move(toAdd));

    if (returnValue)
    {
      isDirty(true);
      hasData(true);
    };

    return returnValue;
  }

  /// @brief Moves the reference iterator to the first object in the reference list.
  /// @returns Pointer to the next astrometry object.
  /// @throws 0x200C - ASTROFILE: Astrometry HDB does not exist.
  /// @version 2013-08-27/GGB - Code changed for bug fix (Bug #1210902)
  /// @version 2012-01-21/GGB - Function created.

  CAstrometryObservation *CAstroFile::astrometryObjectFirst()
  {
    if (!astrometryHDB_)
    {
      ACL_ERROR(0x200C);
    }
    else
    {
      return astrometryHDB_->astrometryObjectFirst();
    }
  }

  /// @brief Moves the reference iterator to the next object in the list.
  /// @returns Pointer to the next astromery object.
  /// @throws 0x200C - ASTROFILE: Astrometry HDB does not exist.
  /// @version 2012-01-21/GGB - Function created.

  CAstrometryObservation *CAstroFile::astrometryObjectNext()
  {
    if (!astrometryHDB_)
    {
      ACL_ERROR(0x200C);
    }
    else
    {
      return astrometryHDB_->astrometryObjectNext();
    }
  }

  /// @brief Wrapper function to calculate the plate constants. Calls the relevant HDB if present.
  /// @returns true - successfull
  /// @returns false - not successful
  /// @throws 0x200C - ASTROFILE: Astrometry HDB does not exist.
  /// @version 2011-12-22/GGB - Function created.

  void CAstroFile::astrometryCalculatePlateConstants()
  {
    if (astrometryHDB_)
    {
      astrometryHDB_->astrometryCalculatePlateConstants();

      isDirty(true);
    }
    else
    {
      ERROR(ACL, 0x200C);
    };
  }

  /// @brief Returns the astrometryHDB pointer.
  /// @returns Raw pointer to the astrometryHDB.
  /// @throws None.
  /// @version 2012-01-09/GGB - Function created.

  CHDBAstrometry *CAstroFile::astrometryHDB()
  {
    return astrometryHDB_;
  }

  /// @brief Determines if there is already an astrometry HDB.
  /// @returns true - astrometry HDB exisits,
  /// @returns false - astrometry HDB does not exist.
  /// @throws None.
  /// @version 2012-01-09/GGB - Function created.

  bool CAstroFile::hasAstrometryHDB() const
  {
    return (static_cast<bool>(astrometryHDB_));
  }

  /// @brief Removes a refernce from the astrometryHDB
  /// @param[in] toRemove: The astrometry object to remove.
  /// @returns true - reference removed
  /// @returns false - reference not found
  /// @throws 0x200C - Astrometry HDB does not exist.
  /// @version 2013-04-08/GGB - Added isDirty(true)
  /// @version 2011-12-11/GGB - Function created.

  bool CAstroFile::astrometryObjectRemove(std::string const &toRemove)
  {
    RUNTIME_ASSERT(ACL, !toRemove.empty(), "Parameter toRemove cannot be empty");

    if (!astrometryHDB_)
    {
      ERROR(ACL, 0x200C);        // Astrometry HDB does not exist.
    }
    else
    {
      isDirty(true);
      return astrometryHDB_->astrometryObjectRemove(toRemove);
    };
  }

  /// @brief Bins the image.
  /// @param[in] hdb: The HDB to address.
  /// @param[in] nsize: The binning parameter.
  /// @throws GCL::CRuntimeAssert
  /// @throws 0x2005 - Incorrect type of HDB.
  /// @details As the image size is changed when a bin-pixels is executed. All the HDB's need to be updated to reflect the
  ///          bin pixels.
  /// @version 2015-08-08/GGB - USe runtime assertion for parameter hdb.
  /// @version 2011-11-27/GGB - Use boost::shared_ptr, smart HDB's and astrometryHDB and photometryHDB
  /// @version 2011-06-10/GGB - Function created.

  void CAstroFile::binPixels(DHDBStore::size_type hdb, unsigned int nsize)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.)");

    HDB[hdb]->binPixels(nsize);
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->binPixels(nsize);
    };

    if (photometryHDB_)
    {
      photometryHDB_->binPixels(nsize);
    };
  }

  /// @brief Returns the calculated or stored blackPoint from the relevant HDB.
  /// @param[in] hdb: The number of the HDB to get the black point from.
  /// @returns The black point value.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2015-09-03/GGB - Added GCL::CRuntimeAssert to check hdb range.
  /// @version 2012-12-01/GGB - Function created.

  FP_t CAstroFile::blackPoint(DHDBStore::size_type hdb)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.)");

    return HDB[hdb]->blackPoint();
  }

  /// @brief Performs the calibration using a dark frame.
  /// @param[in] df: Dark image
  /// @param[in] bf: Bias image.
  /// @param[in] ci: Data for the function.
  /// @throws None.
  /// @details Checks if the bias is selected, scales the dark frame as required and applies the dark frame
  ///          to the image.
  /// @version 2018-09-15/GGB - Updated to use std::unique_ptr.
  /// @version 2012-01-28/GGB - Function created.

  void CAstroFile::calibrateDark(CAstroFile *df, CAstroFile *bf, SCalibrateImage *ci)
  {
    FP_t imageExposure, darkExposure;
    FP_t darkScale;
    CAstroImage *di, *bi;
    std::unique_ptr<CAstroImage> ti;

    if (ci->useBiasFrame)
    {
        // Scale the dark frame

      imageExposure = HDB[0]->EXPOSURE();
      darkExposure = df->HDB[0]->EXPOSURE();

      darkScale = imageExposure / darkExposure;

      di = df->HDB[0]->imageGet();
      bi = df->HDB[0]->imageGet();

      di->createCopy().swap(ti);

      *ti *= darkScale;
      *ti -= *bi;

      HDB[0]->calibrationApplyDark(*ti);
    };

      // Subtract the dark frame from the image.

    HDB[0]->calibrationApplyDark(*df->HDB[0]->imageGet());

  }

  /// @brief Applies the calibration frame to the image.
  /// @version 2012-01-28/GGB - Function created.

  void CAstroFile::calibrateFlat(CAstroFile *ff, SCalibrateImage *ci)
  {
    HDB[0]->calibrationApplyFlat(*ff->HDB[0]->imageGet());
  }

  /// @brief Function to calibrate an image by applying a dark frame.
  /// @details The dark frame file path is passed to the function. The additional parameters allow the overriding of the checks on
  ///          temperature and duration.<br>
  ///          The dark frame needs to be verified to be applicable for the application.
  ///          1. The dimensions of the dark frame must be the the same as the dimensions of the image.<br>
  ///          2. The temperature of the dark frame should be the same as the temperature of the image.<br>
  ///          3. The duration of the dark frame should be the same as the duration of the image.<br>
  /// @throws 0x200F - ASTROFILE: Calibration needs a valid dark frame name.
  /// @throws 0x2010 - ASTROFILE: Dark Calibration Frame must be same dimensions as image.
  /// @throws 0x2011 - ASTROFILE: Dark calibration frame must be same duration as image.
  /// @throws 0x2012 - ASTROFILE: Dark calibration frame should be same temperature as image.
  /// @throws 0x2013 - ASTROFILE: Bias calibration frame needs a valid file name.
  /// @throws 0x2014 - ASTROFILE: Bias calibration frame must be same dimenstions as image.
  /// @throws 0x2015 - ASTROFILE: Flat calibration frame needs a valid file name.
  /// @throws 0x2016 - ASTROFILE: Flat calibration frame must be same dimensions as image.
  /// @version 2012-01-27/GGB - Function created.

  void CAstroFile::calibrateImage(SCalibrateImage *calibrateData)
  {
     std::unique_ptr<CAstroFile> darkFile;
     std::unique_ptr<CAstroFile> biasFile;
     std::unique_ptr<CAstroFile> flatFile;

      // First check the dark frame is correct. There must always be a dark frame present, otherwise an image cannot
      // be calibrated.

    if (calibrateData->useDarkFrame)
    {
      if (!boost::filesystem::exists(calibrateData->darkFramePath))
      {
        ERROR(ACL, 0x200F);    // ASTROFILE: Calibration needs a valid dark frame name.
      };

      //darkFile = CreateFromFile(calibrateData->darkFramePath);    // Will throw on failure.

      if ( !validateImageDimensions(darkFile.get()) )
      {
        ERROR(ACL, 0x2010);    // ASTROFILE: Dark Calibration Frame must be same dimensions as image.
      };

      if (!calibrateData->overrideDarkExposure || !calibrateData->useBiasFrame)
      {
        if (!validateDarkDuration(darkFile.get()) )
        {
          ERROR(ACL, 0x2011);    // ASTROFILE: Dark calibration frame must be same duration as image.
        };
      };

      if (!calibrateData->overrideDarkTemperature)
      {
        if (!validateDarkTemperature(darkFile.get()) )
        {
          ERROR(ACL, 0x2012);    // ASTROFILE: Dark calibration frame should be same temperature as image.
        };
      };
    };

    if (calibrateData->useBiasFrame)
    {
      if (!boost::filesystem::exists(calibrateData->biasFramePath))
      {
        ACL_ERROR(0x2013);    // ASTROFILE: Bias calibration frame needs a valid file name.
      };

      //biasFile = CreateFromFile(calibrateData->biasFramePath);

      if ( !validateImageDimensions(biasFile.get()))
      {
        ACL_ERROR(0x2014);    //ASTROFILE: Bias calibration frame must be same dimenstions as image.
      };
    };

    if (calibrateData->useFlatFrame)
    {
      if (boost::filesystem::exists(calibrateData->flatFramePath))
      {
        ACL_ERROR(0x2015);    // ASTROFILE: Flat calibration frame needs a valid file name.
      };

      //flatFile = CreateFromFile(calibrateData->flatFramePath);

      if ( !validateImageDimensions(flatFile.get()))
      {
        ACL_ERROR(0x2016);    //ASTROFILE: Flat calibration frame must be same dimenstions as image.
      };
    };

    if (calibrateData->useDarkFrame)
    {
      calibrateDark(darkFile.get(), biasFile.get(), calibrateData);
    };

    if (calibrateData->useFlatFrame)
    {
      calibrateFlat(flatFile.get(), calibrateData);
    };
  }

  /// @brief Create an astrometry HDB.
  /// @returns Raw pointer to astrometryHDB
  /// @throws 0x200A - Unable to create HDB
  /// @post isDirty = true
  /// @post hasData = true
  /// @details This will create the data structure, append it to the list of HDB's at the end of the vector and return the index of
  ///          the HDB. If there is already an astrometryHDB defined, then no error will occur. (If an astrometryHDB exists,
  ///          then another one does not need to be created.) Creates the astrometryHDB instance if it does not already exist.
  /// @version 2018-09-22/GGB - Updated to use smart pointers and idioms.
  /// @version 2013-08-30/GGB - Added code to update hasData() and isDirty().
  /// @version 2013-04-12/GGB - Changed return value to the HDB that was created, or already exists.
  /// @version 2011-11-27/GGB - Function created.

  CHDBAstrometry *CAstroFile::createAstrometryHDB()
  {
    if (!astrometryHDB_)
    {
      HDB.emplace_back(std::make_unique<CHDBAstrometry>(this));

      astrometryHDB_ = dynamic_cast<CHDBAstrometry *>(HDB.back().get());
      isDirty(true);
      hasData(true);
    };

    return astrometryHDB_;
  }

  /// @brief Creates an image HDB and adds it to the HDB list. Returns a shared pointer to the image HDB.
  /// @param[in] name: The name of the HDB to create.
  /// @returns Pointer to the created image.
  /// @throws std::bad_alloc
  /// @throws 0x200B - Cannot create HDB with duplicate name.
  /// @version 2015-09-06/GGB - Removed check for non-null value after new function. This will throw a bad_alloc.
  /// @version 2015-09-04/GGB - Updated search loop to use std::any_of.
  /// @version 2011-12-10/GGB - Function created.

  CImageHDB *CAstroFile::createImageHDB(std::string const &name)
  {
    RUNTIME_ASSERT(ACL, !name.empty(), "Parameter name cannot be empty.");

    if (!std::any_of(HDB.begin(), HDB.end(),
                     [&] (std::unique_ptr<CHDB> const &phdb) {return *phdb == name;}) )
    {
      HDB.emplace_back(std::make_unique<CImageHDB>(this, name));
      isDirty(true);
      hasData(true);
      return dynamic_cast<CImageHDB *>(HDB.back().get());
    }
    else
    {
      ACL_ERROR(0x200B);    // Cannot create HDB with duplicate name.
    };
  }

  /// @brief Creates an Ascii Table HDB and adds it to the HDB list.
  /// @param[on] name - The name of the ASCII table.
  /// @returns A shared pointer to the image HDB.
  /// @throws std::bad_alloc
  /// @throws 0x200B - Cannot create HDB with duplicate name.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-09-06/GGB - Removed check for non-null value after new function. This will throw a bad_alloc.
  /// @version 2015-09-04/GGB - Updated search loop to use std::any_of.
  /// @version 2013-08-30/GGB - Added code to update isDirty and hasData.
  /// @version 2011-12-11/GGB - Function created.

  CHDBAsciiTable *CAstroFile::createATableHDB(std::string const &name)
  {
    RUNTIME_ASSERT(ACL, !name.empty(), "Parameter name cannot be empty.");

    if (std::any_of(HDB.begin(), HDB.end(),
                    [&] (std::unique_ptr<CHDB> const &phdb) {return *phdb == name;}) )
    {
      ACL_ERROR(0x200B);    // Cannot create HDB with duplicate name.
    }
    else
    {
      HDB.emplace_back(std::make_unique<CHDBAsciiTable>(this, name));
      isDirty(true);
      hasData(true);
      return dynamic_cast<CHDBAsciiTable *>(HDB.back().get());
    };
  }

  /// @brief Creates an Binary Table HDB and adds it to the HDB list. Returns a shared pointer to the image HDB.
  /// @param[in] name - Name of the HDB to create. Cannot be empty.
  /// @returns Pointer to the newly created binary HDB.
  /// @throws std::bad_alloc
  /// @throws 0x200B - Cannot create HDB with duplicate name.
  /// @post isDirty = true
  /// @post hasData = true
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-09-06/GGB - Removed check for non-null value after new function. This will throw a bad_alloc.
  /// @version 2015-09-04/GGB
  ///   @li Updated search loop to use std::any_of.
  ///   @li Add code to valdidate input paramters (Bug 27)
  /// @version 2013-08-30/GGB - Added code to update isDirty() and hasData().
  /// @version 2011-12-11/GGB - Function created.

  CHDBBinaryTable *CAstroFile::createBTableHDB(std::string const &name)
  {
    RUNTIME_ASSERT(ACL, !name.empty(), "Parameter name cannot be empty.");

    if (std::any_of(HDB.begin(), HDB.end(),
                    [&] (std::unique_ptr<CHDB> const &phdb) {return *phdb == name;}) )
    {
      ACL_ERROR(0x200B);    // Cannot create HDB with duplicate name.
    }
    else
    {
      HDB.emplace_back(std::make_unique<CHDBBinaryTable>(this, name));
      isDirty(true);
      hasData(true);
      return dynamic_cast<CHDBBinaryTable *>(HDB.back().get());
      };
  }

  /// @brief Function to create an astro file from another astrofile that has RGB data.
  /// @note This function may be called from a multi-threaded function, and there may be more than one instance of this function
  /// running at any time.
  /// @details Specifically, all the HDB information needs to be picked up from oldAstroFile, the image information in the primary
  /// HDU needs to be replaced with the colour information speficied in RGBArray and colour. The new AstroFile is returned in the
  /// value newAstroFile.
  /// @throws 0x200D - ASTROFILE: Error accessing HDB[0], no HDB[0] existing.
  /// @version 2013-06-09/GGB - Use smart_pointers for astroFile.
  /// @version 2012-01-07/GGB - Function created.

//  void CAstroFile::CreateFromRGB(PAstroFile oldAstroFile, SRGBHP_Ptr RGBArray, EColour colour, PAstroFile newAstroFile)
//  {
//    std::string colourString;

//    if (newAstroFile)
//    {
//      newAstroFile.reset();
//    };

//    newAstroFile = oldAstroFile->createCopy();    // Use the copy constructor to construct the new object.

//    switch (colour)
//    {
//    case COLOUR_RED:
//      colourString = std::string("Red");
//      break;
//    case COLOUR_GREEN:
//      colourString = std::string("Green");
//      break;
//    case COLOUR_BLUE:
//      colourString = std::string("Blue");
//      break;
//    case COLOUR_LUMINANCE:
//      colourString = std::string("Luminance");
//      break;
//    default:
//      ACL_CODE_ERROR;
//      break;
//    };

//      // Set the new file name.

//    newAstroFile->setFilePath(oldAstroFile->getFilePath() + colourString);

//    if (newAstroFile->HDB.size() == 0)
//    {
//      ACL_ERROR(0x200D);      //ASTROFILE: Error accessing HDB[0], no HDB[0] existing.
//    }
//    else
//    {
//      newAstroFile->HDB[0]->loadFromRGBHP(RGBArray, colour);
//    };
//  }

  /// @brief Create a photometry HDB.
  /// @returns Raw photometryHDB pointer.
  /// @throws std::bad_alloc
  /// @post isDirty = true
  /// @post hasData = true
  /// @details This will create the data structure, append it to the list of HDB's at the end of the vector and return the index of
  ///          the HDB. If there is already an photometryHDB defined, then no error will occur. (If an aphotoometryHDB exists, then
  ///          another one does not need to be created.) Creates the astrometryHDB instance if it does not already exist.
  /// @version 2018-09-22/GGB - Updated to use smart pointer idioms.
  /// @version 2015-09-06/GGB - Removed check for non-null value after new function. This will throw a bad_alloc.
  /// @version 2015-08-09/GGB - Changed c-style casts to static_cast.
  /// @version 2013-08-30/GGB - Added code to update isDirty() and hasData().
  /// @version 2013-08-12/GGB - Added code to capture the egain into the photometry HDB.
  /// @version 2013-04-12/GGB - Changed the return type to PHDBPhotometry.
  /// @version 2011-12-11/GGB - Function created.

  CHDBPhotometry *CAstroFile::createPhotometryHDB()
  {
    TRACEENTER;

    if (!photometryHDB_)
    {
      HDB.emplace_back(std::make_unique<CHDBPhotometry>(this));

      photometryHDB_ = dynamic_cast<CHDBPhotometry *>(HDB.back().get());

      isDirty(true);
      hasData(true);
      try
      {
        FP_t exposure = HDB[0]->EXPOSURE();
        photometryHDB_->keywordWrite(NOAO_EXPTIME, exposure, NOAO_COMMENT_EXPTIME);
        if (keywordExists(0, SBIG_EGAIN))
        {
          FP_t egain = static_cast<double>(keywordData(0, SBIG_EGAIN));
          photometryHDB_->keywordWrite(SBIG_EGAIN, egain, SBIG_COMMENT_EGAIN);
        }
      }
      catch(...)
      {
          // The exposure keywords do not exist. This is not an error, so no need to do anything else, except to catch
          // the exception.
      };
    };

    TRACEEXIT;

    return photometryHDB_;
  }

  /// @brief Deletes all the data stored in the HDB vector.
  /// @throws None.
  /// @version 2011-03-19/GGB - Function created.

  void CAstroFile::deleteAllData()
  {
    HDB.clear();
  }

  /// @brief Pass through function to find the centroid at the specified coordinates.
  /// @param[in] hdb - The number of the HDB with the image.
  /// @param[in] C0 - The center coordinates to search for a centroid.
  /// @param[in] rmax - The maximum radius to search.
  /// @param[in] sensitivity - The sensitivity of the search (sigma)
  /// @returns The centroid if one has been found.
  /// @throws 0x2001 - Invalid HDB number
  /// @throws 0x2005 - Block Type should be BT_IMAGE
  /// @version 2013-03-02/GGB - Changed TPoint to double from float.
  /// @version 2011-11-27/GGB - Convert to boost::shared_ptr, use smart HDB's (CHDB)
  /// @version 2011-06-12/GGB - Function created.

  std::optional<MCL::TPoint2D<FP_t> > CAstroFile::centroid(DHDBStore::size_type hdb, MCL::TPoint2D<AXIS_t> const &c0,
                                                           AXIS_t rmax, int sensitivity) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->centroid(c0, rmax, sensitivity) );
  }

  /// @brief Flips the specified image if possible.
  /// @param[in] hdb - Image to flip.
  /// @post isDirty == true
  /// @throws GCL::CRuntimeAssert
  /// @throws 0x2005 -
  /// @todo hdb should not be required. An image flip should call all the HDB's to flip if required. (Bug 28)
  /// @version 2011-11-27/GGB - Change code to support astrometryHDB and photometryHDB.
  /// @version 2011-05-29/GGB - Function created.

  void CAstroFile::flipImage(size_t hdb)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    if ( HDB[hdb]->HDBType() != BT_IMAGE )
    {
      ACL_ERROR(0x2005);
    }
    else
    {
      HDB[hdb]->imageFlip();

      isDirty(true);

      if (astrometryHDB_)
      {
        astrometryHDB_->imageFlip();
      };

      if (photometryHDB_)
      {
        photometryHDB_->imageFlip();
      };
    };
  }

  /// @brief Returns the renderedImage array
  /// @param[in] hdb - The HDB number.
  /// @returns Pointer to the renderedImage.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-02/GGB - Function created.

  renderImage_t *CAstroFile::getRenderedImage(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->getRenderedImage();
  }

  /// @brief Determines if WCS data exists for the HDB.
  /// @param[in] hdb - The HDB number.
  /// @returns true - If there is WCS data for the HDB.
  /// @returns false - If there is no WCS data for the HDB.
  /// @throws CRuntimeAssert(ACL)
  /// @verison 2016-04-25/GGB - Function created.

  bool CAstroFile::hasWCSData(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return (HDB[hdb]->hasWCSData());
  }

  /// @brief Adds a history item to the specified HDB
  /// @param[in] hdb - The number of the HDB to add the history to. (zero based)
  /// @param[in] history - The history string to add.
  /// @throws CRuntimeAssert
  /// @post isDirty == true
  /// @post hasData == true
  /// @version 2015-08-08/GGB - Runtime assertion for hdb parameter.
  /// @version 2015-07-30/GGB - Runtime assertion that history string is not empty. (Bug 9)
  /// @version 2011-12-04/GGB - Convert to smart pointer and smart HDB, reverse order of arguments.
  /// @version 2011-03-17/GGB - Function created.

  void CAstroFile::historyWrite(DHDBStore::size_type hdb, std::string const &history)
  {
    RUNTIME_ASSERT(ACL, !history.empty(), "History value to be added cannot be empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    HDB[hdb]->historyWrite(history);
    isDirty(true);
    hasData(true);
  }

  /// @brief Returns the exposure time of the specified image.
  /// @param[in] hdb - The number of the HDB to get the exposure of.
  /// @returns The image duration (or zero for no duration)
  /// @throws GCL::CRuntimeError()
  /// @version 2017-08-30/GGB - Function created.

  FP_t CAstroFile::imageExposure(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageExposure();
  }

  /// @brief Returns the filter used in imaging as a string.
  /// @returns The filter name as a string.
  /// @throws None.
  /// @version 2017-08-03/GGB - Function created.

  std::string CAstroFile::imageFilter() const
  {
    std::string returnValue;

    if (keywordExists(0, HEASARC_FILTER))
    {
      returnValue = static_cast<std::string>(keywordData(0, HEASARC_FILTER));
      boost::erase_all(returnValue, "'");
      boost::trim(returnValue);
    }
    else
    {
      returnValue = "Unknown";
    };

    return returnValue;
  }

  /// @brief Floats the image onto a larger canvas.
  /// @param[in] hdb - Image to float.
  /// @param[in] newWidth - The new width
  /// @param[in] newHeight - The new image height.
  /// @param[in] newBkgnd - The new background to use.
  /// @throws 0x2001 -
  /// @throws 0x2005 -
  /// @version 2018-09-22/GGB - Updated to use std::tuple.
  /// @version 2013-05-14/GGB
  ///   @li Changed function name from floatImage to imageFloat.
  ///   @li Changed parameters in astrometry and photometry call to boost::tuple<long, long> const &
  /// @version 2011-11-27/GGB - Change code to support astrometryHDB and photometryHDB.
  /// @version 2011-06-04/GGB - Function created.

  void CAstroFile::imageFloat(DHDBStore::size_type hdb, AXIS_t newWidth, AXIS_t newHeight, long newBkgnd)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    std::tuple<AXIS_t, AXIS_t> oldDim(HDB[hdb]->width(), HDB[hdb]->height());

    HDB[hdb]->imageFloat(newWidth, newHeight, newBkgnd);
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->imageFloat(oldDim, std::tuple<AXIS_t, AXIS_t>(newWidth, newHeight));
    };

    if (photometryHDB_)
    {
      photometryHDB_->imageFloat(oldDim, std::tuple<AXIS_t, AXIS_t>(newWidth, newHeight));
    };
  }

  /// @brief Function to delete a keyword.
  /// @param[in] hdb - The identifier of the HDB to delete.
  /// @param[in] kwd - The name of the keyword to delete.
  /// @note Calling with a keyword that does not exist will not result in an error.
  /// @returns true - The keyword was deleted.
  /// @returns false - The keyword was not deleted.
  /// @throws GCL::CRuntimeAssert(ACL, ...)
  /// @version 2017-07-23/GGB - Function created.

  bool CAstroFile::keywordDelete(DHDBStore::size_type hdb, std::string const &kwd)
  {
    RUNTIME_ASSERT(ACL, !kwd.empty(), "Parameter keyword empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return HDB[hdb]->keywordDelete(kwd);
  }

  /// @brief Flops the specified image if possible.
  /// @param[in] hdb - The HDB to flip.
  /// @throws 0x2001 - Invalid HDB
  /// @throws 0x2005 - Incorrect block type
  //
  // 2011-11-27/GGB - Change code to support astrometryHDB and photometryHDB.
  // 2011-05-29/GGB - Function created.

  void CAstroFile::flopImage(DHDBStore::size_type hdb)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageFlop();
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->imageFlop();
    };

    if (photometryHDB_)
    {
      photometryHDB_->imageFlop();
    };
  }

  /// Determines the average FWHM for the image.
  /// 1. Check if the FWHM keyword is present and return the value if so.
  /// 2. If no keyword find a number of stars of different magnitudes and measure the FWHM
  /// 3. Average the FWHM and write it to the FWHM keyword.
  /// 4. Return the FWHM value.
  //
  //

  std::optional<FP_t> CAstroFile::FWHM()
  {
    return std::optional<FP_t>();
  }

  /// @brief Determines the FWHM for a star.
  /// @throws 0x2001 - Invalid HDB
  /// @throws 0x2005 - Invalid HDB type
  /// @version 2013-04-14/GGB - Function created.

  std::optional<FP_t> CAstroFile::FWHM(DHDBStore::size_type hdb, MCL::TPoint2D<FP_t> const &star) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->FWHM(star);
  }

  /// @brief Gets the image from the HDB numbered hdb.
  /// @details Checks are done to ensure that the hdb value points to a valid position in the vector.
  /// @returns nullptr if not an image
  /// @returns Pointer to CAstroImage if an image
  /// @throws	GCL::CError(0x2001) - Invalid HDB
  /// @throws GCL::CError(0x2005) - Incorrect block type.
  /// @throws GCL::CError(0x2203) - Invalid image data
  /// @version 2017-08-29/GGB - Throw on nullptr. (Bug #49)
  /// @version 2011-11-03/GGB	- Convert to smart pointers and smart HDB's.
  /// @version 2011-03-22/GGB - Function created

  CAstroImage *CAstroFile::getAstroImage(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    CAstroImage *retVal = nullptr;

    retVal = dynamic_cast<CImageHDB *>(HDB[hdb].get())->imageGet();

    if (!retVal)
    {
      ACL_ERROR(0x2203); // Invalid Image Data
    }

    return retVal;
  }

  /// @brief Returns the comment string from the specified HDB
  /// @param[in] hdb - HDB to query.
  /// @returns Function string for the HDB
  /// @throws 0x2001 - Invalid HDB
  /// @version 2013-06-29/GGB - Changed return value to a "std::string" from a "std::string const &"
  /// @version 2011-11-03/GGB	- Convert to smart pointers and smart HDB's.
  /// @version 2011-05-06/GGB - Function created.

  std::string CAstroFile::commentGet(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    return HDB[hdb]->commentGet();
  }

  /// @brief Create a new primary image HDB.
  /// @returns true - function succeeded
  /// @returns false - Function failed
  /// @throws None.
  /// @version 2013-03-09/GGB - Function created.

  bool CAstroFile::createPrimaryImageHDB()
  {
    CHDB *newHDB;

    if ( !HDB.empty() )
    {
      return false;
    }
    else
    {
      newHDB = createImageHDB("PRIMARY");
      newHDB->PRIMARY(true);
      return true;
    };
  }

  /// @brief Creates a primary HDB for the file.
  /// @returns false - Primary HDB already exists.
  /// @returns true - Success
  /// @throws None.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-09-06/GGB - Changed logic flow and introduced returnValue variable.
  /// @version 2015-06-28/GGB - Make file dirty and hasData.
  /// @version 2012-12-30/GGB - Function created.

  bool CAstroFile::createPrimaryHDB()
  {
    bool returnValue = false;

    if ( HDB.empty() )
    {
      HDB.emplace_back(std::make_unique<CHDBPrimary>(this));
      HDB.back()->PRIMARY(true);
      hasData(true);
      isDirty(true);
      returnValue = true;
    };

    return returnValue;
  }

  /// @brief Returns the imageName.
  /// @returns The imageName.
  /// @throws None.
  /// @version 2017-08-10/GGB - Function created.

  std::string CAstroFile::getImageName()
  {
    if (imageName_.empty())
    {
      std::string dateString = getObservationTime().UTC().gregorianDate();
      boost::erase_all(dateString, "-");
      std::string timeString = getObservationTime().UTC().timeOfDay();
      boost::erase_all(timeString, ":");

      imageName_ = getObservationTarget() + "-" + imageFilter() + "-";
      imageName_ += dateString + "T" + timeString;
    };

    return imageName_;
  }

  /// @brief Returns the history string for the specified HDB
  /// @param[in] hdb - The HDB to address
  /// @returns The history string.
  /// @throws 0x2001 - Invalid HDB
  /// @version 2013-06-29/GGB - Changed return value to a "std::string", not a "std::string const &"
  /// @version 2011-11-03/GGB	- Convert to smart pointers and smart HDB's.
  /// @version 2011-05-06/GGB - Function created.

  std::string CAstroFile::historyGet(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    return HDB[hdb]->historyGet();
  }

  /// @brief Returns a pointer to the HDB
  /// @param[in] hdb - The HDB to get the pointer of
  /// @returns Pointer to the requested HDB
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2011-12-17/GGB - Convert to smart pointers
  /// @version 2011-05-06/GGB - Function created.

  CHDB *CAstroFile::getHDB(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    return HDB[hdb].get();
  }

  /// @brief Retrieves the maximum image value from the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @returns The maximum value in the image.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2013-03-09/GGB - Function created.

  FP_t CAstroFile::imageMax(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->getMaxValue() );
  }

  /// @brief Retrieves the mean image value from the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @returns The image mean.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2013-03-09/GGB - Function created.

  FP_t CAstroFile::imageMean(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->getMeanValue() );
  }

  /// @brief Retrieves the minimum image value from the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @returns The minimum image value.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2013-03-09/GGB - Function created.

  FP_t CAstroFile::imageMin(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->getMinValue() );
  }

  /// @brief Returns the observation location.
  /// @returns Pointer to the observation location.
  /// @throws None.
  /// @version 2018-08-25/GGB - Changed return type to raw pointer.
  /// @version 2017-07-23/GGB - Change implementation to std::unique_ptr.
  /// @version 2011-12-16/GGB - Use smart pointer implementation.
  /// @version 2011-07-15/GGB - Function created.

  CObservatory *CAstroFile::getObservationLocation()
  {
    return observationLocation.get();
  }

  /// @brief Returs the observation object or target.
  /// @returns The observation target as a std::string
  /// @throws None.
  /// @version 2017-07-30/GGB - Function created.

  std::string CAstroFile::getObservationTarget() const
  {
    std::string returnValue;

    if (keywordExists(0, FITS_OBJECT))
    {
      returnValue = static_cast<std::string>(keywordData(0, FITS_OBJECT));
    };

    return returnValue;
  }

  /// @brief Returns the observation time.
  /// @returns The Observation Time
  /// @throws None.
  /// @version 2011-12-17/GGB - Smart pointer implementation
  /// @version 2011-07-14/GGB - Function created.

  CAstroTime const &CAstroFile::getObservationTime() const
  {
    return *observationTime;
  }

  /// @brief Returns the observation weather
  /// @returns Pointer to the Observation Weather
  /// @throws None.
  /// @version 2018-08-25/GGB - Changed return type to raw pointer.
  /// @version 2011-12-17/GGB - Smart pointer implementation
  /// @version 2011-07-15/GGB - Function created.

  CWeather *CAstroFile::getObservationWeather()
  {
    return observationWeather.get();
  }

  /// @brief returns the observation coordinates. (IE center of the image.)
  /// @returns The observation coordinates as an RA/Dec pair.
  /// @throws None.
  /// @version 2018-09-05/GGB - Changed targetCoordinates(CAstronomicalCoordinates) to observationTarget(CTargetAstronomy)
  /// @version 2017-07-30/GGB - Function created.

  CAstronomicalCoordinates const &CAstroFile::getTargetCoordinates() const
  {
    return observationTarget->positionCatalog();
  }

  /// @brief Retrieves the stdev image value from the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @returns The stdev from the specified HDB
  /// @throws 0x2001 -
  /// @throws 0x2005 -
  /// @version 2013-03-09/GGB - Function created.

  double CAstroFile::imageStdev(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->getStDevValue() );
  }

  /// @brief Gets the y-dimension of the relevant HDB if it is an image.
  /// @param[in] hdb - The HDB to address.
  /// @returns The height of the image.
  /// @throws 0x2001 -
  /// @throws 0x2005 -
  /// @version 2013-03-09/GGB - Rename to imageHeight.
  /// @version 2011-08-14/GGB - Function created.

  AXIS_t CAstroFile::imageHeight(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->height() );
  }

  /// @brief Gets the x-dimension of the relevant HDB if it is an image.
  /// @param[in] hdb - The HDB to address.
  /// @returns The width of the image.
  /// @throws 0x2001 -
  /// @throws 0x2005 -
  /// @version 2015-06-30/GGB - Removed check of hdb < 0. (unsigned value cannot be < 0)
  /// @version 2013-03-09/GGB - Rename to imageWidth.
  /// @version 2011-11-29/GGB - Use function HDBType() and change return logic.
  /// @version 2011-08-14/GGB - Function created.

  AXIS_t CAstroFile::imageWidth(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return ( HDB[hdb]->width() );
  }

  /// @brief Attempts to create an HDB from the registered classes.
  /// @param[in] hdb - The HDB to address.
  /// @returns Pointer to the newly created HDB.
  /// @throws 0x2018 - HDB Type not registered.
  /// @details If no class claims to be the HDB type, then a null pointer will be called.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-06-30/GGB - Function changed to throw if correct HDB type is not registered. (bug 32)
  /// @version 2012-12-23/GGB - Function created

  std::unique_ptr<CHDB> CAstroFile::HDBCreateClass(fitsfile *file)
  {
    std::vector<SHDBRegister>::iterator iterator;
    bool found = false;

    iterator = HDBRegister.begin();

    while ( (iterator != HDBRegister.end()) && !found )
    {
      if ( (*iterator).testFunction(file) )
      {
        found = true;
      }
      else
      {
        iterator++;
      };
    };

    if (found)
    {
      return ( (*iterator).createFunction(this, file) );
    }
      else
    {
      ACL_ERROR(0x2018);
    };
  }

  /// @brief Identifies all the objects in the image.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] imageSourceList - The container to place the found sources in.
  /// @param[in] paramters - The parameter list to use when searching.
  /// @throws 0x2001 - Invalid HDB Number
  /// @throws 0x2005 - HDB Type should be BT_IMAGE
  /// @version 2014-02-09/GGB - Changed function header to allow parameters to be passed and sourceList to be returned.
  /// @version 2012-07-30/GGB - Function created.

  void CAstroFile::findStars(DHDBStore::size_type hdb,
                             TImageSourceContainer &imageSourceList,
                             SFindSources const &parameters) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->findStars(imageSourceList, parameters);  // Call the HDB to identify all the objects.
  }

  /// @brief Returns the name of the HDB.
  /// @param[in] hdb - The HDB to address.
  /// @returns The name of the specified HDB
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-08/GGB - Use runtime assert for paramter hdb.
  /// @version 2015-06-28/GGB - Remove the check for hdb < 0. size_t is an unsingned so this check is not necessary.
  /// @version 2011-11-13/GGB - Added exception functionallity if the parameter is out of range.
  /// @version 2011-03-17/GGB - Function created.

  std::string CAstroFile::HDBName(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return HDB[hdb]->HDBName();
  }

  /// @brief Adds a new HDB class into the class register store.
  /// @details This allows the HDB creation function to create the correct class when opening FITS and other files.
  /// @returns true - Class registered
  /// @returns false - Class not registered as it is already registered.
  /// @throws None.
  /// @version 2012-12-23/GGB - Function created.

  bool CAstroFile::HDBRegisterClass(SHDBRegister &toRegister)
  {
    std::vector<SHDBRegister>::iterator iterator;
    bool returnValue = true;

    if (HDBRegister.size())
    {
      iterator = HDBRegister.begin();

      while (iterator != HDBRegister.end() && returnValue)
      {
        if ( (*iterator).HDBClassName == toRegister.HDBClassName)
          returnValue = false;
        iterator++;
      };
    };

    if (returnValue)
    {
      HDBRegister.push_back(toRegister);
    };

    return returnValue;
  }

  /// Returns the HDB type
  /// @param[in] hdb - The HDB to address.
  /// @version 2015-08-08/GGB - Use runtime assert for paramter hdb.
  /// @version 2011-11-27/GGB - Changed to use smart pointers (boost::shared_ptr)
  /// @version 2011-11-13/GGB - Added exception functionallity if the parameter is out of range.
  /// @version 2011-03-17/GGB - Function created.

  EBlockType CAstroFile::HDBType(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return HDB[hdb]->HDBType();
  }

  /// @brief Returns the block type of the block with name hdbName.
  /// @param[in] hdbName - The name of the HDB to return the block type of.
  /// @returns The Block Type
  /// @throws None.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-08-08/GGB - Updated to use std::find_if(...)
  /// @version 2012-01-10/GGB - Function created.

  EBlockType CAstroFile::HDBType(std::string const &hdbName) const
  {
    DHDBStore::const_iterator iter;
    EBlockType returnValue = BT_NONE;

    iter = std::find_if(HDB.begin(), HDB.end(),
                        [&] (std::unique_ptr<CHDB> const &hdb) -> bool { return (hdb->HDBName() == hdbName); } );

    if (iter != HDB.end())
    {
      returnValue = (*iter)->HDBType();
    };

    return returnValue;
  }

  /// @brief Returns the number of axes for the relevant HDB.
  /// @param[in] hdb - The hdb number to get the NAXIS value from.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2011-11-27/GGB - Use smart pointers and smart HDB's.
  /// @version 2011-05-11/GGB - Function created.

  NAXIS_t CAstroFile::NAXIS(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    return HDB[hdb]->NAXIS();
  }

  /// @ Gets the value for the n'th axis.
  /// @param[in] hdb - The HDB number to use
  /// @param[in] axis - The axis number to get the dimension of.
  /// @returns NAXISn for specified HDB
  /// @throws 0x2001  - Invalid HDB number
  /// @version 2011-11-27/GGB - Use smart pointers and smart HDB's.
  /// @version 2011-05/27/GGB - Function created.

  AXIS_t CAstroFile::NAXISn(DHDBStore::size_type hdb, size_t axis) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    return HDB[hdb]->NAXISn(axis);
  }

  /// @brief Crops the image. Uses the alternate function to provide the functionality.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] xo - The x origen to crop from
  /// @param[in] yo - The y origen to crop from
  /// @param[in] xd - The x-dimension
  /// @param[in] yd - The y-dimension
  /// @throws None.
  /// @note Calls the @a CAstroFile::imageCrop(hdb, TPoint2D, TPoint2D) function.
  /// @version 2016-03-31/GGB - Added checks for valid HDB number.
  /// @version 2015-06-28/GGB - Removed try{} catch() throw() block.
  /// @version 2011-08-15/GGB - Function created.

  void CAstroFile::imageCrop(DHDBStore::size_type hdb, AXIS_t xo, AXIS_t yo, AXIS_t xd, AXIS_t yd)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    imageCrop(hdb, MCL::TPoint2D<AXIS_t>(xo, yo), MCL::TPoint2D<AXIS_t>(xd, yd));
  }

  /// @brief Function to crop the image.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] origen - The origen of the crop.
  /// @param[in] dims - The dimensions of the crop.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @details As well as cropping the image, the function will call the astrometry HDB and the photometryHDB to inform then
  /// other HDB's of the crop.
  /// @version 2013-03-13/GGB - Changed parameters to <AXIS_t>
  /// @version 2011-12-10/GGB - Added support for astrometry and photomeetry HDB's
  /// @version 2011-11-27/GGB - Changed to use smart pointers (boost::shared_ptr) and smart HDB's (CHDB)
  /// @version 2011-08-15/GGB - Function created.

  void CAstroFile::imageCrop(DHDBStore::size_type hdb, MCL::TPoint2D<AXIS_t> origen, MCL::TPoint2D<AXIS_t> dims)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageCrop(origen, dims);
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->imageCrop(origen, dims);
    };

    if (photometryHDB_)
    {
      photometryHDB_->imageCrop(origen, dims);
    };
  }

  /// @brief Returns true if the data of the hdb is a monochromatic image.
  /// @param[in] hdb - The HDB to address.
  /// @returns HDB->isMonoImage()
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2011-11-27/GGB - Changed to use smart pointers (boost::shared_ptr)
  /// @version 2011-03-21/GGB - Function created.

  bool CAstroFile::isMonoImage(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->isMonoImage();
  }

  /// @brief Returns true if the data of the hdb is a polychromatic image.
  /// @param[in] hdb - number of HDB to check for a poly image.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2011-03-21/GGB - Function created.

  bool CAstroFile::isPolyImage(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->isPolyImage();
  }

  /// Returns the number of keywords for the HDB.
  /// @param[in] hdb - The HDB to address.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2011-11-03/GGB	- Convert to smart pointers and smart HDB's.
  /// @version 2011-05-06/GGB - Function created.

  DHDBStore::size_type CAstroFile::keywordCount(DHDBStore::size_type hdb) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    return HDB[hdb]->keywordCount();
  }

  /// @brief Returns a pointer to the CKeyword instance corresponding to the kwd passed.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] kwd - The keyword to find.
  /// @returns A reference to the keyword instance specified.
  /// @throws 0x2001 - Invalid HDB number.
  /// @version 2017-07-30/GGB
  ///   @li Chamged return ty[e to CFITSKeyword const &.
  ///   @li Removed support for special keywords.
  /// @version 2011-12-30/GGB - Added support for special keyword DATE-OBS
  /// @version 2011-08-31/GGB
  ///   @li Changed return value to PKeyword
  ///   @li Changed HDB::keyword to std::vector.
  ///   @li Keyword uses boost::shared_ptr
  /// @version 2011-05-13/GGB - Function created.

  CFITSKeyword const &CAstroFile::keywordData(DHDBStore::size_type hdb, std::string const &kwd) const
  {
    if ( hdb > HDB.size() )
    {
      ACL_ERROR(0x2001);      // invalid HDB number
    }
    else
    {
      return HDB[hdb]->keywordData(kwd);
    }
  }

  /// @brief Gets the value and comment for the keyword passed from the HDB specified.
  /// @param[in] hdb - The hdb that is being addressed.
  /// @param[in] keyword - The keyword to get value for.
  /// @param[out] value - The value associated with the keyword.
  /// @param[out] comment - The comment associated with the keyword.
  /// @returns true - keyword was found.
  /// @returns false - keyword was not found.
  /// @throws None.
  /// @version 2017-07-31/GGB - Updated as keywordData() now returns CFITSKeyword &.
  /// @version 2011-11-13/GGB - Updated code to reflect use of the boost::shared_ptr library.
  /// @version 2011-05-06/GGB - Function created.

  bool CAstroFile::keywordData(DHDBStore::size_type hdb, std::string const &keyword, std::string &value, std::string &comment) const
  {
    bool returnValue = false;

    if (keywordExists(hdb, keyword))
    {
      CFITSKeyword const &kwd = keywordData(hdb, keyword);      // Call the routine to get the information.

      value = static_cast<std::string>(kwd);
      comment = kwd.comment();
      returnValue = true;
    };

    return returnValue;
  }

  /// @brief Searches if the keyword exists and returns true if the keyword is already in the list of keywords.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] kwd - The keyword to search for.
  /// @returns true - keyword does exist in the specified HDB
  /// @returns false - keyword does not exist in the specified HDB
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-09/GGB - Use runtime assert for check for valid HDB number.
  /// @version 2011-12-04/GGB - Converted to smart HDB and smart pointers.
  /// @version 2011-07-16/GGB - Function created.

  bool CAstroFile::keywordExists(DHDBStore::size_type hdb, std::string const &kwd) const
  {
    RUNTIME_ASSERT(ACL, !kwd.empty(), "Parameter keyword empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return HDB[hdb]->keywordExists(kwd);
  }

  /// @brief Returns a reference to the HDB's keyword map.
  /// @details This allows a calling application to directly iterate and access the underlying keywords.
  /// @param[in] hdb - The HDB to address.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2015-08-09/GGB - Use runtime assert for check for valid HDB number.
  /// @version 2011-11-15/GGB - Function created.

  DKeywordStore &CAstroFile::keywords(DHDBStore::size_type hdb)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return HDB[hdb]->keywordStore();
  }

  /// @brief Returns the type of the keyword.
  /// @param[in] hdb - The HDB to address.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-09/GGB - Use runtime assert for check for valid HDB number.
  /// @version 2011-12-04/GGB - Converted to smart pointers and smart HDB's.
  /// @version 2011-09-01/GGB - Changed from std::map to std::vector
  /// @version 2011-07-15/GGB - Function created.

  KWType CAstroFile::keywordType(DHDBStore::size_type hdb, std::string const &kwd) const
  {
    RUNTIME_ASSERT(ACL, !kwd.empty(), "Paramter keyword empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "hdb parameter out of range.");

    return HDB[hdb]->keywordType(kwd);
  }

  /// @brief Writes a keyword to the specified HDB.
  /// @param[in] hdb: The HDB to address.
  /// @param[in] keyword: The keyword name
  /// @param[in] data: The keyword data
  /// @param[in] comment: Comment for the keyword.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2017-07-23/GGB - Function created.

  void CAstroFile::keywordWrite(DHDBStore::size_type hdb, std::string const &keyword, double const &value,
                                std::string const &comment)
  {
    RUNTIME_ASSERT(ACL, !keyword.empty(), "The keyword parameter cannot be empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    keywordWrite(hdb, std::make_unique<CFITSKeywordDouble>(keyword, value, comment));
  }

  /// @brief Writes a keyword to the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] keyword - The keyword name
  /// @param[in] data - The keyword data
  /// @param[in] comment - Comment for the keyword.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2017-08-04/GGB - Function created.

  void CAstroFile::keywordWrite(DHDBStore::size_type hdb, std::string const &keyword, std::int16_t const &value,
                                std::string const &comment)
  {
    RUNTIME_ASSERT(ACL, !keyword.empty(), "The keyword parameter cannot be empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    keywordWrite(hdb, std::make_unique<CFITSKeywordInt16>(keyword, value, comment));
  }

  /// @brief Writes a keyword to the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] keyword - The keyword name
  /// @param[in] data - The keyword data
  /// @param[in] comment - Comment for the keyword.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2017-07-23/GGB - Function created.

  void CAstroFile::keywordWrite(DHDBStore::size_type hdb, std::string const &keyword, std::int32_t const &value,
                                std::string const &comment)
  {
    RUNTIME_ASSERT(ACL, !keyword.empty(), "The keyword parameter cannot be empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    keywordWrite(hdb, std::make_unique<CFITSKeywordInt32>(keyword, value, comment));
  }

  /// @brief Adds a keyword to the specified HDB.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] keyword - The keyword name
  /// @param[in] data - The keyword data
  /// @param[in] comment - Comment for the keyword.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2016-04-11/GGB - Changed keyword support to the FITSKeyword hierarchy.
  /// @version 2013-03-07/GGB - Changed return type to void.
  /// @version 2012-12-26/GGB
  ///   @li Changed function name
  ///   @li Pass onto other form of function to perform the write.
  /// @version 2011-12-11/GGB
  ///   @li Use new form of HDB storage.
  ///   @li Add return value to function.
  /// @version 2011-08-31/GGB
  ///   @li Changed HDB::keyword from std::map to std::vector
  ///   @li Use boost::shared_ptr for keywords, rather than pointers.
  ///   @li Added code to ensure that the hdb value is within bounds.
  /// @version 2011-03-17/GGB - Function created.

  void CAstroFile::keywordWrite(DHDBStore::size_type hdb, std::string const &keyword, std::string const &value,
                                std::string const &comment)
  {
    RUNTIME_ASSERT(ACL, !keyword.empty(), "The keyword parameter cannot be empty.");
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    keywordWrite(hdb, std::make_unique<CFITSKeywordString>(keyword, value, comment));
  }

  /// @brief Adds the data to the keyword in the relevant HDB.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] data - The keyword to write.
  /// @throws GCL::CRuntimeAssert
  /// @note If the keyword does not already exist, it will be created.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-08-09/GGB - Use runtime assert to check for valid HDB number.
  /// @version 2011-12-18/GGB - Convert to shared_ptr and smart HDB's
  /// @version 2011-07-18/GGB - Function created.

  void CAstroFile::keywordWrite(DHDBStore::size_type hdb, std::unique_ptr<CFITSKeyword> data)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter HDB >= HDB.size()");

    HDB[hdb]->keywordWrite(std::move(data));
    isDirty(true);
    hasData(true);
  }

  /// @brief General load function. Uses the extension to determine the specific load function to call.
  /// @throws GCL::CError(ACL, ...)
  /// @version 2017-08-01/GGB - Added call to processTargetCoordinates().
  /// @version 2017-07-24/GGB - Function created.

  void CAstroFile::loadFromFile(boost::filesystem::path const &fileName)
  {
    std::string ext = fileName.extension().string();

    boost::algorithm::to_upper(ext);

    if ( (ext == ".FTS") ||
         (ext == ".FIT") ||
         (ext == ".FITS") )
    {
      fitsfile *file;

      CFITSIO_TEST(fits_open_diskfile, &file, fileName.string().c_str(), READONLY);
      loadFromFITS(file);
      CFITSIO_TEST(fits_close_file, file);
    }
    else if (ext == ".ST7")
    {
      loadFromSBIG(fileName);
    }
    else if (ext == ".SBIG")
    {
      ACL_ERROR(0x000D);    // Unable to open file type of type selected.
    }
    else if (ext == ".JPG")
    {
      ACL_ERROR(0x000D);    // Unable to open file type of type selected.
    }
    else if (ext == ".TIFF")
    {
      ACL_ERROR(0x000D);    // Unable to open file type of type selected.
    }
#ifdef USE_LIBRAW
    else if ( (ext == ".DNG") ||
              (ext == ".PEF") )
    {
      newFile.reset(new CRAWAstroFile(filePath));
    }
#endif // USE_LIBRAW
    else
    {
      CODE_ERROR(ACL);
    };
  }

  /// @brief Loads data from a FITS file. The file can have a .fts or .fit extension.
  /// @details The primary HDU is read first, followed by any extension HDU's. Once all the information has been read, the
  /// FITS file is closed by this routine.
  /// @param[in] file - The already open fitsfile to load from.
  /// @throws std::bad_alloc.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-09-06/GGB - (Bug 60) Updated to use cfitsio and not CCfits.
  /// @version 2013-03-13/GGB
  ///   @li Moved to class CAstroFile from CFITSAstroFile.
  ///   @li Use scoped pointer for CCfits::FITS pointer.
  /// @version 2012-12-30/GGB - Added support for the CPrimaryHDB type.
  /// @version 2011-05-04/GGB - Function created.

  void CAstroFile::loadFromFITS(fitsfile *file)
  {
    int iIndex;
    int hduCount;
    int naxis;

    CFITSIO_TEST(fits_get_num_hdus, file, &hduCount);

      // Process the Primary HDU

    CFITSIO_TEST(fits_movabs_hdu, file, 1, nullptr);

    CFITSIO_TEST(fits_get_img_dim, file, &naxis);

    if (naxis == 0)
    {
      HDB.emplace_back(std::make_unique<CHDBPrimary>(this));
    }
    else
    {
      HDB.emplace_back(std::make_unique<CImageHDB>(this, ASTROMANAGER_HDB_PRIMARY));
    };

    HDB.back()->readFromFITS(file);


      // Process all the extensions

    for (iIndex = 1; iIndex < hduCount; iIndex++)
    {
      loadExtension(file, iIndex);
    };

    processSpecialKeywords();

    hasData(true);
  }

  /// @brief Loads a FITS file from a memory file.
  /// @param[in] memoryFile - The memory file containing the data.
  /// @returns None.
  /// @throws ...
  /// @version 2017-08-12/GGB - Function created.

  void CAstroFile::loadFromMemory(CFITSMemoryFile &memoryFile)
  {
    fitsfile *file;

    CFITSIO_TEST(fits_open_memfile, &file, "", READONLY, memoryFile.memoryPointer(), memoryFile.memorySize(), FITS_BLOCK, nullptr);
    loadFromFITS(file);
    CFITSIO_TEST(fits_close_file, file);
  }

  /// @brief Loads data from an SBIG camera image file. The file can be have a .ST7 or .SBIG extension.
  /// @throws GCL::CError(ACL, 0x000E)
  /// @version 2017-07-24/GGB - Moved into CAstrofile as a loadFrom... function.
  /// @version 2016-04-11/GGB - Updated to use the new style FITSKeyword hierarchy.
  /// @version 2012-01-28/GGB - Added support to get the sensor temperature into the HDB and other additional information.
  /// @version 2011-12-18/GGB - Changed to smart HDB's and smart pointers.
  /// @version 2011-03-13/GGB - Function created.

  void CAstroFile::loadFromSBIG(boost::filesystem::path const &fileName)
  {
    std::unique_ptr<CSBIGImg> imageFile(new CSBIGImg());
    unsigned short xbin, ybin;

      // Check that the file is a SBIG file.

    if (imageFile->OpenImage(fileName.string().c_str()) == SBFE_NO_ERROR)
    {

      HDB.emplace_back(std::make_unique<CImageHDB>(this, ASTROMANAGER_HDB_PRIMARY));
      CImageHDB *newHDB = dynamic_cast<CImageHDB *>(HDB.back().get());

        // File was opened succesfully.
        // Read all the keywords and store in the data block

      newHDB->NAXIS(2);
      newHDB->NAXISn(1, imageFile->GetWidth());
      newHDB->NAXISn(2, imageFile->GetHeight());

      newHDB->BITPIX(SHORT_IMG);

        // Grab the exposure time from the image.

      newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(NOAO_EXPTIME, imageFile->GetExposureTime(), SBIG_COMMENT_EXPTIME));

        // Grab the pixel sizes from the image.

      newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_PIXELSIZEX, imageFile->GetPixelWidth()/1000));
      newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_PIXELSIZEY, imageFile->GetPixelHeight()/1000));

        // Grab the CCD temperature from the image.

      newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_CCDTEMP, imageFile->GetCCDTemperature(), SBIG_COMMENT_CCDTEMP));

        // Grab the camera model from the image.

      newHDB->keywordWrite(std::make_unique<CFITSKeywordString>(FITS_INSTRUMENT, imageFile->GetCameraModel(), FITS_COMMENT_INSTRUMENT));

        // Grab the filter from the image.

      if (imageFile->GetFilter() != "")
      {
        newHDB->keywordWrite(std::make_unique<CFITSKeywordString>(HEASARC_FILTER, imageFile->GetFilter(), HEASARC_COMMENT_FILTER));
      };

        // Grab the binning information from the image.

      imageFile->GetBinning(xbin, ybin);
      //keyword.reset(new CFITSKeywordUInt08(SBIG_XBINNING, xbin, SBIG_COMMENT_XBINNING));
      //newHDB->keywordWrite(keyword);
      //keyword.reset(new CFITSKeywordUInt08(SBIG_YBINNING, xbin, SBIG_COMMENT_YBINNING));
      //newHDB->keywordWrite(keyword);

        // Grab the gain information

      newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_EGAIN, imageFile->GetEGain(), SBIG_COMMENT_EGAIN));

        // Grab the telescope information

      if (imageFile->GetFocalLength() >=  0)
      {
        newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_FOCALLEN, imageFile->GetFocalLength() * PCL::IN_to_MM, SBIG_COMMENT_FOCALLEN));
      };

      if (imageFile->GetApertureDiameter() >= 0)
      {
        newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_APTDIA, imageFile->GetApertureDiameter() * PCL::IN_to_MM, SBIG_COMMENT_APTDIA));
      };

      if (imageFile->GetApertureArea() >= 0)
      {
        newHDB->keywordWrite(std::make_unique<CFITSKeywordDouble>(SBIG_APTAREA, imageFile->GetApertureArea() * MCL::pow2(PCL::IN_to_MM), SBIG_COMMENT_APTAREA));
      };

        // Grab the software information

      newHDB->keywordWrite(std::make_unique<CFITSKeywordString>(HEASARC_CREATOR, imageFile->GetSoftware(), HEASARC_COMMENT_CREATOR));

        // Create the astro image for the HDB

      //newHDB->imageSet(CAstroImage::CreateAstroImage(SHORT_IMG, newHDB->NAXIS(), newHDB->NAXISn(), imageFile->GetImagePointer()));

      processSpecialKeywords();

      bHasData = true;
    }
    else
    {
      // Error while opening file.

      ACL_ERROR(0x000E);    // Error while opening file.
    };
  }

  /// @brief Function to load a .DNG image into memory. Uses the Adobe .DNG toolkit for the functionality to
  /// @throws
  /// @version  2011-12-25/GGB - Function created.

#ifdef USE_LIBRAW
  void CAstroFile::loadFromRaw()
  {
    CImageHDB_Ptr newHDB(new CImageHDB(this, astroManager_HDB_PRIMARY));
    LibRaw *iProcessor = new LibRaw;

    if (hasData())
      deleteAllData();		// Ensure the astrofile is clear before loading more data.

    if ( iProcessor->open_file(filePath.string().c_str()) == LIBRAW_SUCCESS)
    {
      iProcessor->unpack();
      iProcessor->dcraw_process();

      observationTime.reset(new CAstroTime(iProcessor->imgdata.other.timestamp));

      newHDB->loadFromRAW(iProcessor);
      HDB.push_back(newHDB);

      if (iProcessor)
      {
        delete iProcessor;
        iProcessor = nullptr;
      };
    }
    else
    {
      if (iProcessor)
      {
        delete iProcessor;
        iProcessor = nullptr;
      };
      ACL_ERROR(0x200E);      // ASTROFILE: Error while opening RAW file.
    };
  }
#endif // USE_LIBRAW

  /// @brief Loads data from the relevant keywords into the observationLocation structure.
  /// @throws None.
  /// @version 2017-08-03/GGB - Function created.

  void CAstroFile::processObservationLocation()
  {
    if (keywordExists(0, NOAO_OBSERVATORY))
    {
      observationLocation->siteName(static_cast<std::string>(keywordData(0, NOAO_OBSERVATORY)));
    };

    if (keywordExists(0, UCOLICK_LATITUDE))
    {
      try
      {
        observationLocation->latitude(static_cast<FP_t>(keywordData(0, UCOLICK_LATITUDE))); // This should be a double value
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + UCOLICK_LATITUDE);
      }
    }
    else if (keywordExists(0, MAXIM_LATITUDE))
    {
      try
      {
        observationLocation->latitude(static_cast<FP_t>(keywordData(0, MAXIM_LATITUDE))); // This should be a double value
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + MAXIM_LATITUDE);
      }
    }
    else if (keywordExists(0, SBIG_LATITUDE))
    {
      try
      {
        observationLocation->latitude(parseLatitude(static_cast<std::string>(keywordData(0, SBIG_LATITUDE))));
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + SBIG_LATITUDE);
      }
    }

    if (keywordExists(0, UCOLICK_LONGITUDE))
    {
      try
      {
        observationLocation->longitude(static_cast<FP_t>(keywordData(0, UCOLICK_LONGITUDE)));
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + UCOLICK_LONGITUDE);
      }
    }
    else if (keywordExists(0, MAXIM_LONGITUDE))
    {
      try
      {
        observationLocation->longitude(static_cast<FP_t>(keywordData(0, MAXIM_LONGITUDE)));
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + MAXIM_LONGITUDE);
      }

    }
    else if (keywordExists(0, SBIG_LONGITUDE))
    {
      try
      {
        observationLocation->longitude(parseLongitude(static_cast<std::string>(keywordData(0, SBIG_LONGITUDE))));
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + SBIG_LONGITUDE);
      }
    }

    if (keywordExists(0, ASTROMANAGER_ALTITUDE))
    {
      try
      {
        observationLocation->altitude(static_cast<int>(std::stod(keywordData(0, ASTROMANAGER_ALTITUDE))));
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + ASTROMANAGER_ALTITUDE);
      }
    }
    else if (keywordExists(0, MAXIM_ALTITUDE))
    {
      try
      {
        observationLocation->altitude(static_cast<int>(std::stod(keywordData(0, MAXIM_ALTITUDE))));
      }
      catch(...)
      {
        WARNINGMESSAGE("Invalid format for keyword: " + MAXIM_ALTITUDE);
      }

    }
  }

  /// @brief Loads information about the telescope into the relevant memory structure.
  /// @throws None.
  /// @pre 1. The file must have been loaded before this is called.
  /// @version 2017-08-05/GGB - Function created.

  void CAstroFile::processObservationTelescope()
  {
      // Keywords with possible relevance

    if (keywordExists(0, FITS_TELESCOPE))
    {
      observationTelescope->telescopeName(static_cast<std::string>(keywordData(0, FITS_TELESCOPE)));
      boost::erase_all(observationTelescope->telescopeName(), "'");
      boost::trim(observationTelescope->telescopeName());
    }
    else if (keywordExists(0, ITELESCOPE_TELESCOPE))
    {
      observationTelescope->telescopeName(static_cast<std::string>(keywordData(0, ITELESCOPE_TELESCOPE)));
      boost::erase_all(observationTelescope->telescopeName(), "'");
      boost::trim(observationTelescope->telescopeName());
    };

    if (keywordExists(0, SBIG_FOCALLEN))
    {
      observationTelescope->focalLength(static_cast<double>(keywordData(0, SBIG_FOCALLEN)));
    };
    if (keywordExists(0, SBIG_APTDIA))
    {
      observationTelescope->aperture(static_cast<double>(keywordData(0, SBIG_APTDIA)));
    }
    else if (keywordExists(0, SBIG_APTAREA))
    {
        // Convert from area to diameter. (Area = PI * r^2)

      observationTelescope->aperture(static_cast<double>(keywordData(0, SBIG_APTAREA)));
      observationTelescope->aperture() /= MCL::PI;
      observationTelescope->aperture() = std::sqrt(observationTelescope->aperture());
      observationTelescope->aperture() *= 2;
    };
  }

  /// @brief Loads the observation time into the relevant memory structure.
  /// @throws None.
  /// @pre 1. The file must have been loaded before this is called.
  /// @version 2011-07-15/GGB - Function created.

  void CAstroFile::processObservationTime()
  {
    std::string szTimeSys;
    ETimeScale timeSystem = ACL::TS_NONE;
    struct std::tm time;

    if (keywordExists(0, FITS_TIMESYS))
    {
        // This gives us the time system in use.

      szTimeSys = static_cast<std::string>(keywordData(0, FITS_TIMESYS));

        // Strip any quotation "'" marks from the string.

      boost::erase_all(szTimeSys, "'");

        // Strip any spaces " " from the string.

      boost::trim(szTimeSys);

      if (szTimeSys == FITS_TIMESYS_UTC)
      {
        timeSystem = ACL::TS_UTC;
      }
      else if (szTimeSys == FITS_TIMESYS_UT)
      {
        timeSystem = ACL::TS_UT;
      }
      else if (szTimeSys == FITS_TIMESYS_TAI)
      {
        timeSystem = ACL::TS_TAI;
      }
      else if (szTimeSys == FITS_TIMESYS_AT)
      {
        timeSystem = ACL::TS_TAI;
      }
      else if (szTimeSys == FITS_TIMESYS_ET)
      {
        timeSystem = ACL::TS_ET;
      }
      else if (szTimeSys == FITS_TIMESYS_TT)
      {
        timeSystem = ACL::TS_TT;
      }
      else if (szTimeSys == FITS_TIMESYS_TDT)
      {
        timeSystem = ACL::TS_TDT;
      }
      else if (szTimeSys == FITS_TIMESYS_TDB)
      {
        timeSystem = ACL::TS_TDB;
      }
      else if (szTimeSys == FITS_TIMESYS_TCG)
      {
        timeSystem = ACL::TS_TCG;
      }
      else if (szTimeSys == FITS_TIMESYS_TCB)
      {
        timeSystem = ACL::TS_TCB;
      }
      else
      {
        ACL_ERROR(0x0200);      // FITS: TIMESYS timescale unknown or undefined.
      };
    };

    if (keywordExists(0, ASTROMANAGER_JD))
    {
        // This is easy, just reset and construct with the JD and the relevant timeSystem.

      observationTime.reset(new CAstroTime(static_cast<double>(keywordData(0, ASTROMANAGER_JD)), timeSystem));
    }

    // DATE-OBS should be in the format "YYYY-MM-DDTHH:mm:ss"

    else if ((keywordExists(0, FITS_DATEOBS)) && (parseDATE_OBS(static_cast<std::string>(keywordData(0, FITS_DATEOBS)), &time)))
    {
      observationTime.reset(new CAstroTime(&time, (timeSystem == ACL::TS_NONE) ? ACL::TS_UTC : timeSystem));
    }
    else if ((keywordExists(0, ASTROMANAGER_DATEHP)) && (parseDATE_OBS(static_cast<std::string>(keywordData(0, FITS_DATEOBS)), &time)))
    {
      observationTime.reset(new CAstroTime(&time, (timeSystem == ACL::TS_NONE) ? ACL::TS_UTC : timeSystem));
    }
    else if ((keywordExists(0, FITS_DATE)) && (parseDATE_OBS(static_cast<std::string>(keywordData(0, FITS_DATEOBS)), &time)))
    {
        // Note, this may only have the date in it.

        /// @todo extend to include the TIME and UT fields to discover the time if required.

      observationTime.reset(new CAstroTime(&time, (timeSystem == ACL::TS_NONE) ? ACL::TS_UTC : timeSystem));
    }
  }

  /// @brief Function to process all the special keywords.
  /// @pre The entire astroFile must be loaded before calling this function.
  /// @throws None.
  /// @version 2017-08-13/GGB - Function created.

  void CAstroFile::processSpecialKeywords()
  {
    processObservationTelescope();
    processObservationTime();
    processTargetCoordinates();
    processObservationLocation();
    processWeather();
  }

  /// @brief Reads target coordinate values until a valid target coordinate value is obtained.
  /// @throws None.
  /// @pre 1. The file must have been loaded before this is called.
  /// @version 2018-09-23/GGB - Added imageCenter member.
  /// @version 2017-08-01/GGB - Function created.

  void CAstroFile::processTargetCoordinates()
  {
    bool bRA = false, bDEC = false;
    std::string system;
    std::string epoch;
    std::string equinox;

    if (keywordExists(0, FITS_RADECSYS))
    {
      system = static_cast<std::string>(keywordData(0, FITS_RADECSYS));

        // Remove quotation marks and spaces.

      boost::erase_all(system, "'");
      boost::trim(system);

      if (system == "FK5")
      {
        //targetCoordinates->setReferenceSystem(RS_FK5);
      }
      else if (system == "ICRS")
      {
        //targetCoordinates->setReferenceSystem(RS_ICRS);
      }
      else if (system == "FK4")
      {
        //targetCoordinates->setReferenceSystem(RS_FK4);
      }
      else
      {
        WARNINGMESSAGE("Unknown Coordinate System: " + system);
      };
    }
    else
    {
      INFOMESSAGE("No Coordinate system specified, using FK5");
    };

    if (keywordExists(0, FITS_EPOCH))
    {
      epoch = static_cast<std::string>(keywordData(0, FITS_EPOCH));

      try
      {
        //targetCoordinates->setEpoch(convertEpoch(epoch));
      }
      catch(...)
      {
        WARNINGMESSAGE("Unknown Epoch: " + epoch);
      };
    }
    else
    {
      INFOMESSAGE("No Epoch specified, using J2000");
    }


    if (keywordExists(0, FITS_EQUINOX))
    {
      equinox = static_cast<std::string>(keywordData(0, FITS_EQUINOX));
      try
      {
        //targetCoordinates->setEquinox(convertEpoch(equinox));
      }
      catch(...)
      {
        WARNINGMESSAGE("Unknown Equinox:" + equinox);
      };
    }
    else
    {
      INFOMESSAGE("No Equinox specified, using J2000");
    };

    try
    {
      if (keywordExists(0, MAXIM_RA))
      {
        imageCenter_.RA(parseRA(static_cast<std::string>(keywordData(0, MAXIM_RA))));
        observationTarget->positionCatalog().RA(imageCenter_.RA());
        bRA = true;
      }
      else if (keywordExists(0, MAXIM_OBJECTRA))
      {
        imageCenter().RA(parseRA(static_cast<std::string>(keywordData(0, MAXIM_OBJECTRA))));
        observationTarget->positionCatalog().RA(imageCenter_.RA());
        bRA = true;
      };

      if (keywordExists(0, MAXIM_DEC))
      {
        imageCenter().DEC(parseDEC(static_cast<std::string>(keywordData(0, MAXIM_DEC))));
        observationTarget->positionCatalog().DEC(imageCenter_.DEC());
        bDEC = true;
      }
      else if (keywordExists(0, MAXIM_OBJECTDEC))
      {
        imageCenter().DEC(parseDEC(static_cast<std::string>(keywordData(0, MAXIM_OBJECTDEC))));
        observationTarget->positionCatalog().DEC(imageCenter_.DEC());
        bDEC = true;
      };
    }
    catch(...)
    {
        // Catch any errors generated by the parsing functions.
    };
  }

  /// @brief Processes weather keywords.
  /// @throws None.
  /// @version 2017-08-13/GGB - Function created.

  void CAstroFile::processWeather()
  {
//    try
//    {
//      if ( (keyword == MAXIM_BOLTAMBT) ||
//           (keyword == MAXIM_DAVAMBT) ||
//           (keyword == astroManager_AMBTEM))
//      {
//        observationWeather->temperature(PCL::CTemperature(std::stod(keyword), PCL::TU_C));
//        returnValue = true;
//      }
//      else if ( (keyword == MAXIM_DAVBAROM) ||
//                (keyword == astroManager_AMBPRE))
//      {
//        observationWeather->pressure(PCL::CPressure(std::stod(keyword) * 100, PCL::PU::PA));
//        returnValue = true;
//      }
//      else if ( (keyword == MAXIM_BOLTHUM) ||
//                (keyword == MAXIM_DAVHUM) ||
//                (keyword == astroManager_AMBHUM) )
//      {
//        observationWeather->RH(std::stod(keyword));
//        returnValue = true;
//      };
//    }
//    catch(std::invalid_argument &)
//    {
//      LOGMESSAGE(warning, "Unable to convert"  + keyword + " value (" + value + ") to valid value.");
//    }
//    catch(std::out_of_range &)
//    {
//      LOGMESSAGE(warning, "Unable to convert " + keyword + " value (" + value + ") to valid value.");
//    }
  }

  /// @brief Returns the photometryHDB pointer.
  /// @returns Raw Pointer to the photometry HDB
  /// @throws None.
  /// @version 2012-11-11/GGB - Function created.

  CHDBPhotometry *CAstroFile::photometryHDB()
  {
    return photometryHDB_;
  }

  /// @brief Tests of the photometry HDB already exists.
  /// @returns true - If the photometry HDB exists.
  /// @returns false - The photometry HDB does not exist.
  /// @throws None.
  /// @version 2012-11-11/GGB - Function created.

  bool CAstroFile::hasPhotometryHDB() const
  {
    if (photometryHDB_)
    {
      return true;
    }
    else
    {
      return false;
    };
  }

  /// @brief Adds a new object into the photometry list.
  /// @param[in] toAdd: The observation to add to the list.
  /// @throws None.
  /// @version 2018-10-07/GGB - Changed return value to void and parameter to shared_ptr.
  /// @version 2013-08-30/GGB - Changed logic to ensure that isDirty() and hasData() is updated.
  /// @version 2013-04-08/GGB - Added isDirty(true)
  /// @version 2012-11-11/GGB - Function created.

  void CAstroFile::photometryObjectAdd(std::shared_ptr<CPhotometryObservation> toAdd)
  {
    TRACEENTER;

    if (!photometryHDB_)
    {
      createPhotometryHDB();
    };

    photometryHDB_->photometryObjectAdd(toAdd);

    isDirty(true);
    hasData(true);

    TRACEEXIT;
  }

  /// @brief Returns the number of photometry objects in the photometry list.
  /// @returns The number of photometry objects in the list.
  /// @throws None.
  /// @version 2013-08-03/GGB - Function created.

  size_t CAstroFile::photometryObjectCount() const
  {
    if (photometryHDB_)
    {
      return photometryHDB_->photometryObjectCount();
    }
    else
    {
      return 0;   // No HDB implies no objects.
    };
  }

  /// @brief Returns the first photometry object.
  /// @returns The first photometry object in the photometry list.
  /// @throws 0x2017 - ASTROFILE: Photometry HDB does not exist.
  /// @version 2013-08-30/GGB - Changed to throw exception when no photometry HDB.
  /// @version 2012-11-11/GGB - Function created.

  CPhotometryObservation *CAstroFile::photometryObjectFirst()
  {
    if (!photometryHDB_)
    {
      ACL_ERROR(0x2017);
    }
    else
    {
      return photometryHDB_->photometryObjectFirst();
    }
  }

  /// @brief Returns the next photometry object.
  /// @throws 0x2017 - ASTROFILE: Photometry HDB does not exist.
  /// @version 2013-08-30/GGB - Throw exception when there is no photometryHDB.
  /// @version 2012-11-11/GGB - Function created.

  CPhotometryObservation *CAstroFile::photometryObjectNext()
  {
    if (!photometryHDB_)
    {
      ACL_ERROR(0x2017);
    }
    else
    {
      return photometryHDB_->photometryObjectNext();
    }
  }

  /// Removes the specified object from the photometry list.
  //
  // 2013-08-17/GGB - Changed parameter to std::string.
  // 2013-04-08/GGB - Added isDirty(true)
  // 2012-11-11/GGB - Function created.

  bool CAstroFile::photometryObjectRemove(std::string const &toRemove)
  {
    assert(!toRemove.empty());

    if (!photometryHDB_)
    {
      return false;
    }
    else
    {
      isDirty(true);
      return photometryHDB_->photometryObjectRemove(toRemove);
    };
  }

  /// Removes all the photometry objects from the list.
  //
  // 2013-05-10/GGB - Function created.

  void CAstroFile::photometryObjectRemoveAll()
  {
    if (photometryHDB_)
    {
      isDirty(true);
      photometryHDB_->photometryObjectRemoveAll();
    };
  }

  /// @brief Converts image coordinates to RA/Dec.
  /// @param[in] hdb - The hdb number to address
  /// @param[in] toConvert - The pixel address to convert.
  /// @returns The coordinates converted to RA/Dec.
  /// @throws GCL::CRuntimeAssert
  /// @version 2013-08-21/GGB - Function created.

  std::optional<CAstronomicalCoordinates> CAstroFile::pix2wcs(DHDBStore::size_type hdb, MCL::TPoint2D<FP_t> const &toConvert) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->pix2wcs(toConvert);
  }

  /// @brief Performs photometry on a single point.
  /// @details The CCD coordinates and annulus information are used to determine the centroidand the photometry parameters.
  /// @param[in] hdb: The HDB number to perform the photometry on.
  /// @param[in] po: The photometry object.
  /// @throws 0x2001 - Invalid HDB number
  /// @version 2018-10-07/GGB - Changed paramter to a reference.
  /// @version 2013-04-07/GGB - Changed type to PPhotometryObservation
  /// @version 2012-11-10/GGB - Function created.

  void CAstroFile::pointPhotometry(DHDBStore::size_type hdb, CPhotometryObservation &po)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");

    isDirty(true);
    HDB[hdb]->pointPhotometry(po);
  }

  /// @brief Function to resample the image.
  /// @throws  0x2001 - Invalid HDB number
  /// @throws 0x2005 - Block Type should be BT_IMAGE
  /// @version 2011-11-27/GGB - Implement smart pointers (boost::shared_ptr), smart HDB's (CHDB, astrometryHDB, photometryHDB
  /// @version 2011-06-07/GGB - Function created.

  void CAstroFile::imageResample(DHDBStore::size_type hdb, AXIS_t width, AXIS_t height)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageResample(width, height);
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->imageResample(width, height);
    };

    if (photometryHDB_)
    {
      photometryHDB_->imageResample(width, height);
    };
  }

  /// @brief Rotates the specified image.
  /// @throws 0x2001 - Invalid HDB number
  /// @throws 0x2005 - Block Type should be BT_IMAGE
  /// @version 2011-11-27/GGB
  ///   @li Use smart Pointers (boost::shared_ptr)
  ///   @li Implement astrometryHDB and photometryHDB
  ///   @li Implement smart HDB's (CHDB)
  /// @version 2011-05-30/GGB - Function created.

  void CAstroFile::rotateImage(DHDBStore::size_type hdb, FP_t angle)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageRotate(angle);
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->imageRotate(angle);
    };

    if (photometryHDB_)
    {
      photometryHDB_->imageRotate(angle);
    };
  }

  /// @brief Processes the save command.
  /// @param[in] fileName - The file name to save.
  /// @details Checks the data and dirty flag and then calls saveAsFITS()
  /// Also will check if the filename exists and if it does, it changes the extension to .bak from whatever the existing
  /// extension was. If a .bak file already exists then the existing .bak file will be deleted and a the existing file
  /// renamed.
  /// @note Updates dirty flag.
  /// @throws None.
  /// @version 2015-07-28/GGB - Changed catch (CACLError &) to catch (...)
  /// @version 2013-07-18/GGB - Changed program flow to save as .tmp and then rename after sucess (Bug #1099804)
  /// @version 2011-05-15/GGB - Function created.

  void CAstroFile::save(boost::filesystem::path const &fileName)
  {
    RUNTIME_ASSERT(ACL, !fileName.empty(), "Parameter fileName is empty");

    boost::filesystem::path backupPath(fileName);
    boost::filesystem::path newPath(fileName);
    fitsfile *file;
    int status = 0;

    try
    {
      if ( hasData() )
      {
        newPath.replace_extension(".tmp");

          // Delete any existing .tmp file with the same name. Do not warn the user, just do it silently.

        if (boost::filesystem::exists(newPath))
        {
          boost::filesystem::remove(newPath);
        };

          // Create the FITS file.

        CFITSIO_TEST(fits_create_file, &file, newPath.c_str());
        saveAsFITS(file);
        CFITSIO_TEST(fits_close_file, file);
        isDirty(false);

        if ( boost::filesystem::exists(fileName) )
        {
            // The file does exist. Create the backup file path and check if the backup file path exists.

          backupPath.replace_extension(".bak");

          if ( boost::filesystem::exists(backupPath) )
          {
            boost::filesystem::remove(backupPath);       // Delete .bak
          };

            // Rename the file to the backup file.

          if ( boost::filesystem::exists(fileName) )
          {
            boost::filesystem::rename(fileName, backupPath);    // Rename .fts to .bak
          };
        };

        boost::filesystem::rename(newPath, fileName);   // Rename .tmp to .fts

        isDirty(false);
      };
    }
    catch (...)
    {
        // Ensure that the .tmp file is removed.

      if (boost::filesystem::exists(newPath))
      {
        boost::filesystem::remove(newPath);
      };

      throw;
    };
  }

  /// @brief Saves the contents of the memory structure as a FITS file.
  /// @note The fileName is not changed by this function.
  /// @version 2018-09-22/GGB - Updated to use std::unique_ptr.
  /// @version 2015-09-03/GGB - Use cfitsio instead of ccfits.
  /// @version 2013-08-10/GGB - Changed Astrometry table to binary table.
  /// @version 2013-07-18/GGB - Changed to take parameter "boost::filesystem::path const &) (Bug #1099804)
  /// @version 2013-05-09/GGB - Changed Photometry table to a binary table.
  /// @version 2012-01-17/GGB - Function created.

  void CAstroFile::saveAsFITS(fitsfile *file)
  {
    std::for_each(HDB.begin(), HDB.end(), [&] (std::unique_ptr<CHDB> const &p) {p->writeToFITS(file);});
  }

  /// @brief Saves a file into memory.
  /// @param[in] memoryFile - The memoryFile to save the data to.
  /// @throws
  /// @version 2017-08-12/GGB - Function created.

  void CAstroFile::save(CFITSMemoryFile &memoryFile)
  {
    fitsfile *file;

      // Create the FITS file.

    CFITSIO_TEST(fits_create_memfile, &file, memoryFile.memoryPointer(), memoryFile.memorySize(), FITS_BLOCK,
                                     &CFITSMemoryFile::reallocate);
    saveAsFITS(file);
    CFITSIO_TEST(fits_close_file, file);

    isDirty(false);
  }

  /// @brief Changes the image in the astro file's HDB to a new image.
  /// @param[in] hdb: The number of the HDB
  /// @param[in] newImage: Pointer to the new image.
  /// @post This instance takes ownership of the unique_ptr.
  /// @throws 0x2001 - Invalid HDB number
  /// @throws 0x2005 - Block Type should be BT_IMAGE
  /// @version 2011-11-27/GGB - Change to smart pointers, smart HDB's
  /// @version 2011-05-22/GGB - Function created.

  void CAstroFile::setAstroImage(DHDBStore::size_type hdb, std::unique_ptr<CAstroImage> &newImage)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageSet(newImage);
  }

  /// Sets the observation location.
  /// @param[in] newLocation: The new location to set.
  /// @throws CRuntimeAssert() Prevents reset to a NULL pointer.
  /// @version 2011-12-17/GGB - Smart pointer implmentation
  /// @version 2011-07-15/GGB - Function created.

//  void CAstroFile::setObservationLocation(PLocation newLocation)
//  {
//    RUNTIME_ASSERT(ACL, !newLocation, "Parameter newLocation cannot have a nullptr.");

//    observationLocation = newLocation;

//    bHasData = bDirty = true;
//  }

  /// @brief Sets the observation time.
  /// @param[in] newTime - The new time to set for the observation.
  /// @throws None.
  /// @version 2011-12-17/GGB - Smart pointer implmentation
  /// @version 2011-07-15/GGB - Function created.

  void CAstroFile::setObservationTime(CAstroTime const &newTime)
  {
    *observationTime = newTime;

    bHasData = bDirty = true;
  }

  /// @brief Sets the observation weather (Replaces the current object)
  /// @param[in] newWeather: The new weather instance.
  /// @throws None.
  /// @version 2011-12-17/GGB - Smart pointer implmentation
  /// @version 2011-07-15/GGB - Function created.

  void CAstroFile::setObservationWeather(std::unique_ptr<CWeather> newWeather)
  {
    RUNTIME_ASSERT(ACL, !newWeather, "Parameter newWeather cannot have a nullptr.");

    observationWeather.swap(newWeather);

    bHasData = bDirty = true;
  }

  /// @brief Solves the plate and sets up the WCS information for the specified image.
  /// @param[in] - The HDB to solve for.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2012-08-12/GGB - Function created.

  bool CAstroFile::plateSolve(DHDBStore::size_type hdb, AXIS_t plane)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->plateSolve(plane);
  }

  /// @brief Transforms an image (translate, rotate scale).
  /// @throws CRuntimeAssert
  /// @throws As thrown by CImageHDB::imageTransform()
  /// @throws As thrown by CAstrometryHDB::imageTransform()
  /// @throws As thrown by CHDBPhotometry::imageTransform()
  /// @version 2011-11-27/GGB - Changed to smart pointers, included astrometryHDB and photometryHDB.
  /// @version 2011-07-08/GGB - Function created.

  void CAstroFile::TRS(DHDBStore::size_type hdb, MCL::TPoint2D<FP_t> const &c0, MCL::TPoint2D<FP_t> const &ct,
    FP_t th, FP_t sc, MCL::TPoint2D<FP_t> const &pix, std::unique_ptr<bool> &maskPlane)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    HDB[hdb]->imageTransform(c0, ct, th, sc, pix, maskPlane);
    isDirty(true);

    if (astrometryHDB_)
    {
      astrometryHDB_->imageTransform(c0, ct, th, sc, pix, maskPlane);
    };

    if (photometryHDB_)
    {
      photometryHDB_->imageTransform(c0, ct, th, sc, pix, maskPlane);
    };
  }

  /// @brief Checks that the exposure of this image matches the exposure of the passed astrofile image.
  /// @throws 0x4000 - KEYWORD: Keyword EXPTIME must be a numeric value. (float, double, int, long)
  /// @throws 0x4001 - KEYWORD: Keyword EXPOSURE must be a numeric value. (float, double, int, long).
  /// @version 2015-08-09/GGB - Changed c-style casts to static_cast
  /// @version 2012-01-28/GGB - Function created.

  bool CAstroFile::validateDarkDuration(CAstroFile *af)
  {
    FP_t darkExposure = 1, imageExposure = 1;
    bool bReturnValue = true;

      // Get the exposure duration for this image.

    if (HDB[0]->keywordExists(NOAO_EXPTIME) )
    {
      imageExposure = static_cast<FP_t>(HDB[0]->keywordData(NOAO_EXPTIME));
    }
    else if (HDB[0]->keywordExists(HEASARC_EXPOSURE) )
    {
      imageExposure = static_cast<FP_t>(HDB[0]->keywordData(HEASARC_EXPOSURE));
    }
    else
    {
      bReturnValue = false;
    }

      // Get the dark exposure duration

    if (bReturnValue)
    {
      if (af->keywordExists(0, NOAO_EXPTIME) )
      {
        darkExposure = static_cast<FP_t>(af->keywordData(0, NOAO_EXPTIME));
      }
      else if (af->keywordExists(0, HEASARC_EXPOSURE) )
      {
        darkExposure = static_cast<FP_t>(af->keywordData(0, HEASARC_EXPOSURE));
      }
      else
      {
        bReturnValue = false;
      }
    };

      // Check that the exposures are the same.

    if (bReturnValue)
    {
      if ( abs(1 - (imageExposure / darkExposure)) < 0.01)      // 1% tolerance
      {
        bReturnValue = true;
      }
      else
      {
        bReturnValue = false;
      };
    };

    return bReturnValue;
  }

  /// Verifys that the sensor temperature on this image and on the dark frame are the same.
  /// throws: 0x4002 - KEYWORD: Keyword 'CCD-TEMP' must be a numeric value. (float, double, int, long).
  /// @version 2015-08-09/GGB - Changed c-style casts to static_cast
  // 2012-01-28/GGB - Function created.

  bool CAstroFile::validateDarkTemperature(CAstroFile *af)
  {
    FP_t imageTemperature = 272, darkTemperature = 272;
    bool bReturnValue = true;

    if (HDB[0]->keywordExists(SBIG_CCDTEMP))
    {
      imageTemperature = static_cast<FP_t>(HDB[0]->keywordData(SBIG_CCDTEMP));
    }
    else
    {
      bReturnValue = false;
    };

    if (bReturnValue)
    {
      if (af->keywordExists(0, SBIG_CCDTEMP))
      {
        darkTemperature = static_cast<FP_t>(af->keywordData(0, SBIG_CCDTEMP));
      }
      else
      {
        bReturnValue = false;
      };
    };

    if (bReturnValue)
    {
      if ( abs(1 - (imageTemperature / darkTemperature)) < 0.1)   // 10% error allowed.
      {
        bReturnValue = true;
      }
      else
      {
        bReturnValue = false;
      };
    };

    return bReturnValue;
  }

  /// @brief Validates the dimensions of the two images.
  /// @param[in] af - The other astroFile.
  /// @returns true - Images are the same dimensions
  /// @returns false - Images have different dimensions
  /// @throws None.
  /// @version 2012-01-28/GGB - Function created.

  bool CAstroFile::validateImageDimensions(CAstroFile *af)
  {
    bool bReturnValue = true;
    NAXIS_t index;

    if ( HDB[0]->NAXIS() == af->HDB[0]->NAXIS())
    {
      for (index = 1; (index <= HDB[0]->NAXIS()) && bReturnValue; index++)
      {
        if (HDB[0]->NAXISn(index) != af->HDB[0]->NAXISn(index))
        {
          bReturnValue = false;
        }
      };
    }
    else
    {
      bReturnValue = false;
    };

    return bReturnValue;
  }

  /// @brief Returns the calculated or stored whitePoint from the relevant HDB.
  /// @param[in] hdb - The HDB number to access the white point.
  /// @returns The whitepoint of the image.
  /// @throws CRuntimeAsset - Invalid HDB
  /// @version 2015-09-03/GGB - Added check that the hdb is an image.
  /// @version 2012-12-01/GGB - Function created.

  FP_t CAstroFile::whitePoint(DHDBStore::size_type hdb)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb(" + std::to_string(hdb) + ") out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.");

    return HDB[hdb]->whitePoint();
  }

  /// @brief Calls the code to load the appropriate type of extension data.
  /// @param[in] file: The FITS file to load the extension from.
  /// @param[in[ extension: The number of the extension to load.
  /// @throws {0x2018, "ASTROFILE: HDB Type not registered."},
  /// @throws Lots.
  /// @note Checks for registered extension HDU's before testing the "traditional" HDU types.
  /// @version 2018-09-22/GGB - Updated to use smart pointers.
  /// @version 2013-08-10/GGB - Changed Astrometry table to Binary table.
  /// @version 2013-05-09/GGB - Changed Photometry table to Binary table.
  /// @version 2012-01-21/GGB - Function created.

  void CAstroFile::loadExtension(fitsfile *file, int extension)
  {
    RUNTIME_ASSERT(ACL, file != nullptr, "Parameter file cannot be nullptr.");

    int status = 0;
    int hduType;
    CHDB *hdb = nullptr;
    char szExtName[FLEN_CARD];
    std::string extName;

    if (fits_read_key(file, TSTRING, FITS_EXTNAME.c_str(), szExtName, nullptr, &status) == KEY_NO_EXIST)
    {
      // Extension name not found.

      extName = "Extension " + std::to_string(extension);
    }
    else if (status == 0)
    {
      extName = std::string(szExtName);
    }
    else
    {
      throw CFITSException();       // Some other error. Needs to be thrown.
    };

    CFITSIO_TEST(fits_movabs_hdu, file, extension, &hduType);

    switch (hduType)
    {
      case IMAGE_HDU:
      {
        hdb = createImageHDB(extName);
        hdb->readFromFITS(file);
        break;
      };
      case ASCII_TBL:
      {
        hdb = createATableHDB(extName);
        hdb->readFromFITS(file);
        break;
      };
      case BINARY_TBL:
      {
        if (extName == ASTROMANAGER_HDB_ASTROMETRY)
        {
          astrometryHDB_ = createAstrometryHDB();
          astrometryHDB_->readFromFITS(file);
        }
        else if (extName == ASTROMANAGER_HDB_PHOTOMETRY)
        {
          photometryHDB_ = createPhotometryHDB();
          photometryHDB_->readFromFITS(file);
        }
        else
        {
          createBTableHDB(extName);
        };
        break;
      };
      default:
      {
        // Check the type of the "XTENSION" and load the data if it is a custom HDB.
        // This is done here as custom types are identified by

        if (!HDBRegister.empty())
        {
          DHDBRegisterIterator iterator = std::find_if(HDBRegister.begin(), HDBRegister.end(),
                                                       [&] (SHDBRegister r) {return r.testFunction(file);});

          if (iterator != HDBRegister.end())
          {
            HDB.emplace_back((*iterator).createFunction(this, file));
            HDB.back()->readFromFITS(file);
          }
          else
          {
            ACL_ERROR(0x2018);  // "ASTROFILE: HDB Type not registered."
          };
        }
        else
        {
          ACL_ERROR(0x2018);  // "ASTROFILE: HDB Type not registered."
        }
        ACL_ERROR(0x1000);  // Invalid xtension data
        break;
      };
    };
  }

  /// @brief Function to get the objectProfile.
  /// @param[in] hdb - The HDB to use
  /// @param[in] centroid - The centroid of the object
  /// @param[in] radius - The radius to centroid to.
  /// @param[out] data - The output data.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2013-05-18/GGB - Function created.

  void CAstroFile::objectProfile(DHDBStore::size_type hdb, MCL::TPoint2D<FP_t> centroid,
                                 AXIS_t radius, std::vector<std::tuple<FP_t, FP_t> > &data) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Parameter hdb out of range.");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Incorrect HDB type. (Must be an image.)");

    HDB[hdb]->objectProfile(centroid, radius, data);
  }

  /// @brief Render the image as a default type of image.
  /// @param[in] hdb - The HDB number to address. (First = 0)
  /// @param[in] rm - Render mode.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-09/GGB - Use runtime assert to check for valid HDB number.
  /// @version 2013-07-13/GGB - Function created.

  void CAstroFile::renderImage(DHDBStore::size_type hdb, ERenderMode rm)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Invalid HDB Number");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Invalid HDB Type");

    HDB[hdb]->renderImage(rm);
  }

  /// @brief Set the colour values for the specified image plane.
  /// @param[in] hdb - The number of the HDB
  /// @param[in] ip - The number of the image plane to set the values for.
  /// @param[in] colour - The RGB colour to assign to the image plane.
  /// @param[in] trans - The transparancy to assign to the image plane.
  /// @throws GCL::RuntimeAssert
  /// @version 2015-08-01/GGB - Function created.

  void CAstroFile::setImagePlaneColourValues(DHDBStore::size_type hdb, size_t ip, SColourRGB colour, FP_t trans)
  {
    RUNTIME_ASSERT(ACL, hdb >= HDB.size(), "Invalid HDB Number");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Invalid HDB Type");

    HDB[hdb]->setImagePlaneColourValues(ip, colour, trans);
  }

  /// @brief Function to set the parameters for rendering the image.
  /// @param[in] hdb - The HDB number. (zero based)
  /// @param[in] ip - The image plane number (zero based)
  /// @param[in] bp - The black point
  /// @param[in] wp - The white point.
  /// @param[in] invert - Invert the image?
  /// @param[in] tf - The transfer function to use.
  /// @param[in] tfp - The transfer function parameter.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-01/GGB - Function created.

  void CAstroFile::setImagePlaneRenderFunction(DHDBStore::size_type hdb, size_t ip, FP_t bp, FP_t wp, bool invert,
                                               ETransferFunction tf, FP_t tfp)
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Invalid HDB Number");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Invalid HDB Type");

    HDB[hdb]->setImagePlaneRenderFunction(ip, bp, wp, invert, tf, tfp);
  }

  /// @brief Converts RA/Dec to image coordinates.
  /// @param[in] hdb - The HDB to address.
  /// @param[in] toConvert - The coordinates to convert.
  /// @returns The converted coordinates.
  /// @throws GCL::CRuntimeAssert
  /// @note Calls the libWCS library function wcs2pix to perform the conversion.
  /// @version 2015-08-09/GGB - Use runtime assert to check for valid HDB number and type.
  /// @version 2013-08-21/GGB - Function created.

  std::optional<MCL::TPoint2D<FP_t> > CAstroFile::wcs2pix(DHDBStore::size_type hdb, CAstronomicalCoordinates const &toConvert) const
  {
    RUNTIME_ASSERT(ACL, hdb < HDB.size(), "Invalid HDB Number");
    RUNTIME_ASSERT(ACL, HDB[hdb]->HDBType() == BT_IMAGE, "Invalid HDB Type");

    return HDB[hdb]->wcs2pix(toConvert);
  }

}	// namespace ACL
