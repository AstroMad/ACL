//*********************************************************************************************************************************
//
// PROJECT:							Astronomy Class Library
// FILE:								HDBImage
// SUBSYSTEM:						Astronomical HDB classes
// LANGUAGE:						C++
// TARGET OS:						None.
// LIBRARY DEPENDANCE:	SCL, CFitsIO, boost.
// NAMESPACE:						ACL
// AUTHOR:							Gavin Blakeman (GGB)
// LICENSE:             GPLv2
//
//                      Copyright 2011-2018 Gavin Blakeman.
//                      This file is part of the Astronomy Class Library (ACL)
//
//                      ACL is free software: you can redistribute it and/or modify it under the terms of the GNU General
//                      Public License as published by the Free Software Foundation, either version 2 of the License, or
//                      (at your option) any later version.
//
//                      ACL is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
//                      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//                      for more details.
//
//                      You should have received a copy of the GNU General Public License along with ACL.  If not,
//                      see <http://www.gnu.org/licenses/>.
//
// OVERVIEW:						A number of classes supporting file IO of astronomical data including images.
//											The classes are designed to present a single interface to the other astro library
//											classes while supporting several different file types.
//
//											File types supported for input are:   FITS
//																								            SBIG image files
//                                                            DNG Files
//                                                            RAW Files
//                      File types supported for output are": FITS
//
//                      The CAstroFile class is modelled around the FITS file format and is designed to work seamlessly with FITS
//                      files. While opening other types of files is supported, some information will be created on the fly.
//                      To ensure that all information generated by image manipulation is saved correctly, the information must
//                      be saved in the FITS format. Information will be lost if it is saved in any other format.
//
//                      The CAstroFile class also provides some observation management functionality as there are keywords that
//                      are automatically linked to observation information.
//
//
// CLASSES INCLUDED:		CImageHDB       - Class to encapsulate image HDB data
//
// CLASS HIERARCHY:     CHDB
//                        - CImageHDB
//                        - CHDBAsciiTable
//                          - CAstrometryHDB
//                          - CHDBPhotometry
//                        - CHDBBinTable
//
// HISTORY:             2015-09-22 GGB - astroManager 2015.09 release
//                      2013-09-30 GGB - astroManager 2013.09 release.
//                      2013-03-22 GGB - astroManager 2013.03 release.
//                      2013-02-10 GGB - File created.
//
//*********************************************************************************************************************************

#include "../include/HDBImage.h"

  // ACL header files.

#include "../include/AstroImageFunctions.hpp"
#include "../include/AstroImageMono.h"
#include "../include/AstroImagePoly.h"
#include "../include/constants.h"
#include "../include/FITS.h"
#include "../include/FITSException.h"

  // libWCS functions. Modify header to link. (Comment out  #ifdef __STDC__, #else and #endif test and comment out K&R prototypes.)

#include "wcs.h"

  // Miscellaneous headers

#include <GCL>

namespace ACL
{
   struct SRawData8
  {
    boost::uint16_t R;
    boost::uint16_t G;
    boost::uint16_t B;
    boost::uint16_t G2;
  };

  //*******************************************************************************************************************************
  //
  // class CImageHDB
  //
  //*******************************************************************************************************************************

  /// @brief Creator function for the class. Returns an instance of the class.
  /// @param[in] parent - The astrofile instance that "owns" this instance.
  /// @returns A pointer to a new image HDB.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-08/GGB - Changed assertion to runtime assertion.
  /// @version 2012-12-23/GGB - Function created.

  PHDB CImageHDB::createHDB(CAstroFile *parent)
  {
    RUNTIME_ASSERT(ACL, parent != nullptr, "Parameter parent cannot be nullptr.");

    return PHDB(new CImageHDB(parent, ""));
  }

  /// @brief Constructor taking the name of the HDB to be created.
  /// @param[in] np - The astrofile instance that "owns" this instance.
  /// @param[in] name - The name of the HDU.
  /// @throws GCL::CRuntimeAssert
  /// @version 2013-02-10/GGB - Add WCS support.
  /// @version 2011-11-27/GGB - Function created.

  CImageHDB::CImageHDB(CAstroFile *np, std::string const &name) : CHDB(np, name), data(nullptr), WCSInformation(nullptr)
  {
    RUNTIME_ASSERT(ACL, np != nullptr, "Parameter np == nullptr");

    GCOUNT(1);
    PCOUNT(0);
  }

  /// @brief Copy constructor for the class.
  /// @param[in] toCopy - The instance to make a copy of.
  /// @throws None.
  /// @version 2017-08-27/GGB - Added call to WCSProcess.
  /// @version 2013-06-08/GGB - Function created.

  CImageHDB::CImageHDB(CImageHDB const &toCopy) : CHDB(toCopy), data(nullptr), pixelSize(toCopy.pixelSize), WCSInformation(nullptr)
  {
    if (toCopy.data)
    {
      data = toCopy.data->createCopy();
    };

    if (toCopy.WCSInformation)
    {
      WCSInformation = wcsxinit(toCopy.WCSInformation->plate_ra, toCopy.WCSInformation->plate_dec,
        toCopy.WCSInformation->plate_scale, toCopy.WCSInformation->xrefpix, toCopy.WCSInformation->yrefpix,
        toCopy.WCSInformation->nxpix, toCopy.WCSInformation->nypix, toCopy.WCSInformation->rot, toCopy.WCSInformation->equinox,
        toCopy.WCSInformation->epoch, toCopy.WCSInformation->ptype);

      WCSProcess();
    };
  }

  /// @brief Destructor for the class.
  /// @details Delete any WCS information.
  /// @throws None.
  /// @version 2013-07-02/GGB - Added code to delete (Bug #1197373)
  /// @version 2013-02-10/GGB - Function created.

  CImageHDB::~CImageHDB()
  {
    if (data)
    {
      delete data;
      data = nullptr;
    };

    if (WCSInformation)
    {
      wcsfree(WCSInformation);
      WCSInformation = nullptr;
    };
  }

  /// @brief Function to get the BITPIX value.
  /// @returns The BITPIX value
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  /// @version 2012-11-27/GGB - Function created.

  int CImageHDB::BITPIX() const
  {
    if (data)
    {
      return data->BITPIX();
    }
    else
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    }
  }

  /// @brief Sets new values of BITPIX.
  /// @param[in] bp - The new BITPIX value.
  /// @details The value passed is checked to ensure that it is a valid value.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  //
  // 2012-11-27/GGB - Changed to support BITPIX in CImagePlane.
  // 2011-12-18/GGB - Function created.

  void CImageHDB::BITPIX(int bp)
  {
    if (!data)
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    }
    else
    {
      data->BITPIX(bp);
    };
  }

  /// @brief Determines the initial black point for displaying the image.
  /// @returns The suggested black point for the image.
  /// @throws 0x1907 - ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
  /// @version 2013-07-13/GGB - Added exception if data package == nullptr. Return mean - stdev if no CBLACK keyword.
  /// @version 2012-12-01/GGB - Function created.

  FP_t CImageHDB::blackPoint()
  {
    FP_t bp;

    if (keywordExists(SBIG_CBLACK))
    {
      bp = static_cast<FP_t>(keywordData(SBIG_CBLACK));

      return bp;
    }
    else if (data)
    {
      FP_t mean = data->getMean();
      FP_t stdev = data->getStDev();

      return ACL::blackPoint(mean, stdev);
    }
    else
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    }
  }

  /// @brief Function to get the BSCALE value.
  /// @returns The BSCALE value.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  /// @version 2012-11-30/GGB - Function created.

  FP_t CImageHDB::BSCALE() const
  {
    if (data)
    {
      return data->BSCALE();
    }
    else
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    };
  }

  /// @brief Sets the BSCALE value
  /// @param[in] bscale - The new BSCALE value.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  //
  // 2012-11-30/GGB - Modified for the BSCALE value stored in the CImageplane class
  // 2012-01-14/GGB - Function created.

  void CImageHDB::BSCALE(FP_t bscale)
  {
    if (!data)
    {
      ACL_ERROR(0x1907);
    }
    else
    {
      data->BSCALE(bscale);
    };
  }

  /// @brief Function to get the BZERO value.
  /// @returns The BSCALE value.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  //
  // 2012-11-30/GGB - Function created.

  FP_t CImageHDB::BZERO() const
  {
    if (data)
    {
      return data->BZERO();
    }
    else
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    };
  }

  /// @brief Sets the value of bzero.
  /// @param[in] bzero - The BZERO value to set.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  //
  // 2012-11-30/GGB - Modified for the BSCALE value stored in the CImageplane class
  // 2012-01-14/GGB - Function created.

  void CImageHDB::BZERO(FP_t bzero)
  {
    if (!data)
    {
      ACL_ERROR(0x1907);
    }
    else
    {
      data->BZERO(bzero);
    };
  }

  /// @brief Applies the dark frame to the image.
  /// @param[in] ai - The dark frame to apply.
  /// @throws 0x2007 - Data pointer == NULL
  /// @version 2012-01-28/GGB - Function created.

  void CImageHDB::calibrationApplyDark(CAstroImage const &ai)
  {
    if (data)
    {
      data->applyDark(ai);
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Creates a copy of this HDB.
  /// @returns A smart pointer to a new HDB that is a copy of this.
  /// @throws std::bad_alloc
  /// @version 2013-06-07/GGB - Function created.

  PHDB CImageHDB::createCopy() const
  {
    PHDB returnValue(new CImageHDB(*this));

    return returnValue;
  }

  /// @brief Function to find the centroid.
  /// @param[in] c0 - Center point to search from.
  /// @param[in] rmax - The maximum search radius
  /// @param sensitivity - The search sensitivity
  /// @returns Centroid if found.
  /// @throws 0x2007 - Data pointer == nullptr
  /// @version 2013-08-02/GGB - Added sensitivity parameter.
  /// @version 2011-11-27/GGB - Function created.

  std::optional<MCL::TPoint2D<FP_t> > CImageHDB::centroid(MCL::TPoint2D<AXIS_t> const &c0, AXIS_t rmax, int sensitivity) const
  {
    if (data)
    {
      return data->centroid(c0, rmax, sensitivity);
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Function to extract all the objects in the image.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  /// @version 2012-07-28/GGB - Function created.

  void CImageHDB::findStars(TImageSourceContainer &imageSourceList, const SFindSources &sourceDefaults) const
  {
    if (!data)
    {
      ACL_ERROR(0x1907);  // Data pointer == nullptr
    }
    else
    {
      data->findStars(imageSourceList, sourceDefaults);
    };
  }

  /// @brief Determines the FWHM for a single star.
  /// @param[in] star - Coordinates of the the star to determine the FWHM
  /// @throws GCL::CError(0x2007) - Data pointer == NULL
  /// @version 2014-04-14/GGB - Function created.

  std::optional<FP_t> CImageHDB::FWHM(MCL::TPoint2D<FP_t> const &star) const
  {
    if (!data)
    {
      ACL_ERROR(0x2007);
    }
    else
    {
      return data->FWHM(star);
    };
  }

  /// @brief Determines if there is WCS information for this image.
  /// @param None.
  /// @returns true - If there is WCS data for the image.
  /// @returns false - If there is no WCS data for the image.
  /// @throws None.
  /// @version 2016-04-25/GGB - Function created.

  bool CImageHDB::hasWCSData() const
  {
    return (WCSInformation != nullptr);
  }

  /// @brief Returns the height of an image.
  //
  // 2011-11-27/GGB - Function created.

  AXIS_t CImageHDB::height() const
  {
    if (data)
    {
      return data->height();
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Returns the maximum value of the image.
  //
  // 2013-03-09/GGB - Function created.

  FP_t CImageHDB::getMaxValue() const
  {
    if (data)
    {
      return data->getMax();
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Returns the mean value of the image.
  /// @returns the mean of the image.
  /// @throws GCL::CError(ACL, 0x2007) - Data pointer == nullptr
  /// @version 2013-03-09/GGB - Function created.

  FP_t CImageHDB::getMeanValue() const
  {
    if (data)
    {
      return data->getMean();
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Returns the stdev value of the image.
  /// @returns The std deviation
  /// @throws GCL::CError(ACL, 0x2007) - Data pointer == nullptr
  /// @version 2013-03-09/GGB - Function created.

  FP_t CImageHDB::getStDevValue() const
  {
    if (data)
      return data->getStDev();
    else
      ACL_ERROR(0x2007);    // Data pointer == NULL
  }

  /// @brief Returns the minimum value of the image.
  /// @returns The minimum value present in the image.
  /// @throws GCL::CError(ACL, 0x2007)
  /// @version 2013-03-09/GGB - Function created.

  FP_t CImageHDB::getMinValue() const
  {
    if (data)
    {
      return data->getMin();
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Function to crop an image.
  /// @param[in] origin - The origin of the crop.
  /// @param[in] dims - The dimension of the crop.
  /// @throws GCL::CError(0x2007) - Data pointer == NULL
  /// @version 2013-06-29/GGB - Added history functions.
  /// @version 2011-11-27/GGB - Function created

  void CImageHDB::imageCrop(MCL::TPoint2D<AXIS_t> origin, MCL::TPoint2D<AXIS_t> dims)
  {
    std::string szHistory = "Image Cropped.";

    if (data)
    {
      data->crop(origin, dims);

      firstEdit();
      historyWrite(szHistory);
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Returns the exposure time of the specified image.
  /// @returns The image duration (or zero for no duration)
  /// @throws None.
  /// @version 2017-08-30/GGB - Function created.

  FP_t CImageHDB::imageExposure() const
  {
    FP_t returnValue = 0;

    if (keywordExists(NOAO_EXPTIME))
    {
      returnValue = static_cast<FP_t>(keywordData(NOAO_EXPTIME));
    }
    else if (keywordExists(HEASARC_EXPOSURE))
    {
      returnValue = static_cast<FP_t>(keywordData(HEASARC_EXPOSURE));
    };

    return returnValue;
  }

  /// @brief Function to flip the image.
  /// @throws GCL::CError(0x2007)
  /// @version 2013-06-29/GGB - Added history functions.
  /// @version 2011-11-27/GGB - Function created.

  void CImageHDB::imageFlip()
  {
    std::string szHistory = "Image mirrored vertically.";

    if (data)
    {
      data->flip();

      firstEdit();
      historyWrite(szHistory);
    }
    else
    {
      ACL_ERROR(0x2007);  // Data pointer == NULL
    };
  }

  // Function to flop the image
  //
  // 2013-06-29/GGB - Added history functions.
  // 2011-11-27/GGB - Function created.

  void CImageHDB::imageFlop()
  {
    std::string szHistory = "Image mirrored horizontally.";

    if (data)
    {
      data->flop();

      firstEdit();
      historyWrite(szHistory);
    }
    else
      ACL_ERROR(0x2007);  // Data pointer == NULL
  }

  // Returns a valid pointer to image data.
  // EXCEPTIONS:  0x2007 - Data pointer == NULL
  //
  // 2011-12-10/GGB - Function created.

  CAstroImage *CImageHDB::imageGet()
  {
    if (data)
      return data;
    else
      ACL_ERROR(0x2007);
  }

  // Function to float the image.
  //
  // 2013-06-29/GGB - Added history functions.
  // 2011-11-27/GGB - Function created.

  void CImageHDB::imageFloat(AXIS_t width, AXIS_t height, long bkgnd)
  {
    std::string szHistory = "Image floated";

    if (data)
    {
      data->floatImage(width, height, bkgnd);

      firstEdit();
      historyWrite(szHistory);
    }
    else
      ACL_ERROR(0x2007);  // Data pointer == NULL
  }

  // Resamples the image if there is a valid image.
  // EXCEPTIONS:  0x2007 - Data pointer == NULL
  //
  // 2013-06-29/GGB - Added history functions.
  // 2011-11-27/GGB - Function created.

  void CImageHDB::imageResample(AXIS_t w, AXIS_t h)
  {
    std::string szHistory("Image resampled");

    if (data)
    {
      data->resampleImage(w, h);

      firstEdit();
      historyWrite(szHistory);
    }
    else
      ACL_ERROR(0x2007);    // Data pointer == NULL
  }

  // Function to rotate the image.
  // EXCEPTIONS:  0x2007 - Data pointer == NULL
  //
  // 2013-06-29/GGB - Added history functions.
  // 2011-11-27/GGB - Function created.

  void CImageHDB::imageRotate(FP_t theta)
  {
    std::string szHistory("Image rotated");

    if (data)
    {
      data->rotate(theta);

      firstEdit();
      historyWrite(szHistory);
    }
    else
      ACL_ERROR(0x2007);  // Data pointer == NULL
  }

  /// @brief Tests if the image is a mono image.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2015-09-14/GGB - Updated to use GCL::CRuntimeAssert
  /// @version 2011-12-10/GGB - Function created.

  bool CImageHDB::isMonoImage() const
  {
    RUNTIME_ASSERT(ACL, data != nullptr, "Data pointer == nullptr");

    return data->isMonoImage();
  }

  /// @brief Tests if the image is a poly image.
  /// @throws GCL::CRuntimeAssert(ACL)
  /// @version 2015-09-14/GGB - Updated to use GCL::CRuntimeAssert
  /// @version 2011-12-10/GGB - Function created.

  bool CImageHDB::isPolyImage() const
  {
    RUNTIME_ASSERT(ACL, data != nullptr, "Data pointer == nullptr");

    return data->isPolyImage();
  }

  /// @brief Called if the keyword data contains data about the pixel size.
  /// @throws CCodeError(ACL)
  /// @version 2016-04-16/GGB - Updated to static_cast<FP_t> from (float)
  /// @version 2011-08-31/GGB - Function created.

  void CImageHDB::keywordPixelSize(PFITSKeyword keyword)
  {
    if ((*keyword) == SBIG_PIXELSIZEX)
    {
      getPixelSize().x() = static_cast<FP_t>(*keyword);
    }
    else if ((*keyword) == SBIG_PIXELSIZEY)
    {
      getPixelSize().y() = static_cast<FP_t>(*keyword);
    }
    else
    {
      ACL_CODE_ERROR;
    };
  }

  /// @brief Pass through function to get the number of axis in the image.
  /// EXCEPTIONS:  0x2007 - Data pointer == NULL
  //
  // 2013-07-19/GGB - Function created.

  NAXIS_t CImageHDB::NAXIS() const
  {
    if (data)
      return data->NAXIS();
    else
      ACL_ERROR(0x2007);    // Data pointer == nullptr
  }

  /// @brief Pass through function to get the size of axis naxisn in the image.
  /// @throws 0x2007 - Data pointer == NULL
  //
  // 2013-07-19/GGB - Function created.

  AXIS_t CImageHDB::NAXISn(NAXIS_t naxisn) const
  {
    if (data)
    {
      return data->NAXISn(naxisn);
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == nullptr
    }
  }

  /// @brief Loads the data from the FITS file. This includes the image data as well as the keyword and other data.
  /// @param[in] file - Pointer to the FITS file.
  /// @throws None.
  /// @version 2015-08-11/GGB - Converted to use cfitsio
  /// @version 2013-07-19/GGB - Added code for the change to having the NAXIS and NAXISn values derive from the image plane.
  /// @version 2013-03-13/GGB @li Function name changed to readFromFits and parameter to pointer.
  /// @li Functionality moved to CAstroImage::readFromFITS()
  /// @version 2011-12-17/GGB - Function created.

  void CImageHDB::readFromFITS(fitsfile *file)
  {
    RUNTIME_ASSERT(ACL, file != nullptr, "Parameter file cannot be nullptr");

    CHDB::readFromFITS(file);          // Call the parent to load all the common stuff as well as the keywords.

    data = CAstroImage::CreateAstroImage(naxisn_);
    data->readFromFITS(file);

    WCSProcess();                     // Process the wcs information if it in the header.
  }

  /// @brief Function to bin the pixels.
  /// @param[in] p - Binning parameter.
  /// @throws 0x2007 - Data pointer == NULL
  /// @version 2013-06-29/GGB - Added history functions.
  /// @version 2013-06-23/GGB - Added code to update black and white keywords. (Bug#1193740)
  /// @version 2011-11-27/GGB - Function created

  void CImageHDB::binPixels(unsigned int p)
  {
    std::string szHistory("Image binned.");
    if (data)
    {
      data->binPixels(p);

      firstEdit();
      historyWrite(szHistory);

      if (data->isMonoImage())
      {
        CAstroImageMono *mono = dynamic_cast<CAstroImageMono *>(data);
        ACL::FP_t mean = data->getMean();
        ACL::FP_t stdev = data->getStDev();

        if (mono)
        {
          keywordWrite(SBIG_CBLACK, mean - stdev, SBIG_COMMENT_CBLACK);
          keywordWrite(SBIG_CWHITE, mean + (3 * stdev), SBIG_COMMENT_CWHITE);
        }
        else
          ACL_CODE_ERROR;
      };
    }
    else
      ACL_ERROR(0x2007);    // Data pointer == NULL
  }

  /// @brief Returns the rendered image.
  /// @throws GCL::RuntimeAssert(ACL)
  /// @version 2013-07=13/GGB - Function created.

  renderImage_t *CImageHDB::getRenderedImage() const
  {
    RUNTIME_ASSERT(ACL, data, "data pointer == nullptr")

    return data->getRenderedImage();
  }

  /// @brief Transforms the image.
  /// @throws 0x2007 - Data pointer == NULL
  /// @throws CCodeError
  /// @version 2013-07-08/GGB - Added code to update the min/max, average and black and white point. (Bug #1193634)
  /// @version 2013-06-29/GGB - Added history functions.
  /// @version 2011-11-27/GGB - Function created.

  void CImageHDB::imageTransform(const MCL::TPoint2D<FP_t> &c0, const MCL::TPoint2D<FP_t> &ct, const FP_t &th,
    const FP_t &sc, const MCL::TPoint2D<FP_t> &pix, std::unique_ptr<bool[]> &maskPlane)
  {
    std::string szHistory("Image Transformed");

    if (data)
    {
      data->transform(c0, ct, th, sc, pix, maskPlane);

      firstEdit();
      historyWrite(szHistory);

      if (data->isMonoImage())
      {
        CAstroImageMono *mono = dynamic_cast<CAstroImageMono *>(data);
        ACL::FP_t mean = data->getMean();
        ACL::FP_t stdev = data->getStDev();

        if (mono)
        {
          keywordWrite(SBIG_CBLACK, mean - stdev, SBIG_COMMENT_CBLACK);
          keywordWrite(SBIG_CWHITE, mean + (3 * stdev), SBIG_COMMENT_CWHITE);
        }
        else
        {
          ACL_CODE_ERROR;
        };
      };
    }
    else
      ACL_ERROR(0x2007);    // Data pointer == NULL
  }

  /// @brief Sets the new astro image. The sizes of the images must be the same, otherwise an exception will be thrown.
  /// @throws CError ACL::0x2006 - Incorrect image size
  /// @throws CRuntimeAssert
  /// @version 2011-11-27/GGB - Function created.

  void CImageHDB::imageSet(CAstroImage *newImage)
  {
    RUNTIME_ASSERT(ACL, newImage != nullptr, "The new image cannot be a nullptr.");

    if (data)
    {
      if ( (newImage->width() != data->width() ) &&
           (newImage->height() != data->height()) )
      {
        ACL_ERROR(0x2006);
      };

      delete data;
    };

    data = newImage;
  }

  // Loads an image from a RAW file.
  //
  // 2011-12-26/GGB - Function created.

#ifdef USE_LIBRAW
  bool CImageHDB::loadFromRAW(LibRaw *iProcessor)
  {
    assert(iProcessor != nullptr);

    int width, height, colors, bps;
    SRawData8 *rawData = nullptr;
    CAstroImagePoly *astroImage = nullptr;
    SRGB colour;

    iProcessor->get_mem_image_format(&width, &height, &colors, &bps);

    BITPIX(BP_SHORT);
    NAXIS(colors);
    NAXISn(1, width);
    NAXISn(2, height);
    NAXISn(3, colors);

    PImagePlane red(new CImagePlane(width, height));
    PImagePlane green(new CImagePlane(width, height));
    PImagePlane blue(new CImagePlane(width, height));

    astroImage = new CAstroImagePoly(width, height, colors);

    rawData = (SRawData8 *) iProcessor->imgdata.image;

    for (int index = 0; index < (width * height); index++)
    {
      red->setValue(index, rawData[index].R);
      green->setValue(index, rawData[index].G);
      blue->setValue(index, rawData[index].B);
    };

    colour.R = 255;
    colour.G = 0;
    colour.B = 0;
    astroImage->insertImagePlane(red, colour);

    colour.R = 0;
    colour.G = 255;
    colour.B = 0;
    astroImage->insertImagePlane(green, colour);

    colour.R = 0;
    colour.G = 0;
    colour.B = 255;
    astroImage->insertImagePlane(blue, colour);

    data = astroImage;

    return true;
  }

#endif // USE_LIBRAW

  /// @brief Replaces any data already loaded in the image with the data contained in the image.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be NULL
  //
  // 2012-01-07/GGB - Function created.

  void CImageHDB::loadFromRGBHP(SRGBHP_Ptr RGBData, EColour colour)
  {
    if (data)
      data->loadFromRGBHP(RGBData, colour);
    else
      ACL_ERROR(0x1907);    // HDB: Data package NULL. Should not be NULL
  }

  /// @brief Function to get the profile data.
  /// @param[in] centroid - The centroid of the object
  /// @param[in] radius - The radius to centroid to.
  /// @param[out] data - The output data.
  /// @throws 0x1907 - HDB: Data package NULL. Should not be nullptr
  /// @version 2013-05-18/GGB - Function created.

  void CImageHDB::objectProfile(MCL::TPoint2D<FP_t> centroid, AXIS_t radius, std::vector<boost::tuple<FP_t, FP_t> > &profileData) const
  {
    if (data)
    {
      return data->objectProfile(centroid, radius, profileData);
    }
    else
    {
      ACL_ERROR(0x1907);
    };
  }

  /// @brief Function to get the PEDESTAL value.
  /// @returns The pedestal value
  /// @throws GCL::CError(0x1907) - HDB: Data package NULL. Should not be nullptr
  /// @version 2012-12-01/GGB - Function created.

  int CImageHDB::PEDESTAL() const
  {
    if (data)
    {
      return data->PEDESTAL();
    }
    else
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    };
  }

  /// @brief Converts the pixel coordinates passed to WCS coordinates.
  /// @param[in] toConvert: The coordinates to convert.
  /// @returns RA/DEC of passed CCD coordinates.
  /// @throws None.
  /// @version 2018-01-17/GGB - Updated control flow to have a single if statement to handle all the cases.
  /// @version 2017-09-24/GGB - Updated to use CAngle.
  /// @version 2017-08-25/GGB - Updated to return
  /// @version 2013-08-17/GGB - Added code to convert from degrees to radians in CAstronomicalCoordinates before returning.
  /// @version 2013-02-24/GGB - Changed return type to boost::optional. Changed TPoint2D data type to FP_t. Removed exceptions.
  /// @version 2013-02-17/GGB - Function created.

  std::optional<CAstronomicalCoordinates> CImageHDB::pix2wcs(MCL::TPoint2D<FP_t> const &toConvert) const
  {
    std::optional<CAstronomicalCoordinates> returnValue;
    CAstronomicalCoordinates intermediate;

    if ( WCSInformation &&
         (toConvert.x() >= 0) &&
         (toConvert.y() >= 0) &&
         (toConvert.x() < data->width()) &&
         (toConvert.y() < data->height()) )
    {
      FP_t ra, dec;

      ::pix2wcs(WCSInformation, toConvert.x(), toConvert.y(), &ra, &dec);

      intermediate.setEpoch(WCSInformation->epoch);
      intermediate.setEquinox(WCSInformation->equinox);
      intermediate(ra * MCL::K_D2R, dec * MCL::K_D2R);        // CAngle stores in radians.

      returnValue = intermediate;
    };

    return returnValue;
  }

  /// @brief Determines the plate solution (WCS) for the image.
  /// @param[in] colourPlane - The colourPlane to use to solve the plate.
  /// @returns true - Plate solved.
  /// @returns false - Plate not solved.
  /// @details The function uses the astrometry.net library to perform the solution.
  /// The solving is done in distinct steps
  ///   @li Find the sources in the image to produce the x, y, flux, background list of sources. This can be done with a call to
  ///       findStars.
  ///   @li Call the astroetry.net library to perform the actual solution of the plate.
  ///   @li Update the WCS parameters for the image.
  ///

  bool CImageHDB::plateSolve(AXIS_t colourPlane)
  {
    bool returnValue = false;

    return returnValue;
  }

  /// @brief Performs photometry on a single star or object.
  /// @param[in] po - The photometry object.
  /// @throws 0x2007 - Data pointer == nullptr
  /// @version 2012-11-10/GGB - Function created.

  void CImageHDB::pointPhotometry(SPPhotometryObservation po)
  {
    if (!data)
    {
      ACL_ERROR(0x2007);    // Data pointer == nullptr
    }
    else
    {
      data->photometry(po);
    };
  }

  /// @brief Calls the image rendering function.
  /// @throws 0x2007 -
  /// @version 2013-07-13/GGB - Function created.

  void CImageHDB::renderImage(ERenderMode rm)
  {
    if (data)
    {
      data->renderImage(rm);
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    }
  }

  /// @brief Set the rendering information for the colour plane.
  /// @param[in] ip - The image plane number.
  /// @param[in] bp - The blackpoint for rendering
  /// @param[in] wp - The whitepoint for rendering
  /// @param[in] invert - Invert the image?
  /// @param[in] tf - The transfer function to use.
  /// @param[in] tfp - Parameter for the transfer function.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-01/GGB - Function created.

  void CImageHDB::setImagePlaneRenderFunction(size_t ip, FP_t bp, FP_t wp, bool invert, ETransferFunction tf , FP_t tfp)
  {
    RUNTIME_ASSERT(ACL, data != nullptr, "data cannot be nullptr");

    data->setImagePlaneRenderFunction(ip, bp, wp, invert, tf, tfp);
  }

  /// @brief Set the imageplane colour values.
  /// @param[in] ip - The number of the image plane to set the values for.
  /// @param[in] colour - The RGB colour to assign to the image plane.
  /// @param[in] trans - The transparancy to assign to the image plane.
  /// @throws GCL::CRuntimeAssert
  /// @version 2015-08-01/GGB - Function created.

  void CImageHDB::setImagePlaneColourValues(size_t ip, SColourRGB colour, FP_t trans)
  {
    RUNTIME_ASSERT(ACL, data != nullptr, "data cannot be nullptr");

    data->setImagePlaneColourValues(ip, colour, trans);
  }

  // Checks if the passed keyword has any special meaning. If there is a
  // special meaning for the keyword, the appropriate routine is called to set
  // the special data value.
  // Special data values are stored directly in the HDB and not as keywords.
  // The keyword value is explicitely discarded from the list of keywords when
  // the data is loaded.
  //
  // Return Value:  true - keyword was special and was handled.
  //                false - keyword was not special and was not handled.
  //
  // 2011-09-28/GGB - Function created.

  bool CImageHDB::specialKeyword(PFITSKeyword keyword)
  {
    bool returnValue = false;

    if (CHDB::specialKeyword(keyword))
      returnValue = true;
    else if ((*keyword) == SBIG_PIXELSIZEX)
    {
      keywordPixelSize(keyword);
      returnValue = true;
    }
    else if ((*keyword) == SBIG_PIXELSIZEY)
    {
      keywordPixelSize(keyword);
      returnValue = true;
    }
    return returnValue;
  }

  /// @brief Converts RA/Dec to image coordinates.
  /// @param[in] toConvert: The coordinates to convert.
  /// @returns The image coordinates.
  /// @throws None.
  /// @version 2017-08-27/GGB - Updated to reflect that RA is stored in hours not degrees.
  /// @version 2013-08-21/GGB - Function created.

  std::optional<MCL::TPoint2D<FP_t> > CImageHDB::wcs2pix(CAstronomicalCoordinates const &toConvert) const
  {
    std::optional<MCL::TPoint2D<FP_t>> returnValue;
    MCL::TPoint2D<FP_t> intermediate;
    int offscl;

    if (!WCSInformation)
    {
      return returnValue;
    }
    else
    {
      ::wcs2pix(WCSInformation, static_cast<double>(toConvert.RA().degrees()), static_cast<double>(toConvert.DEC().degrees()),
                &intermediate.x(), &intermediate.y(), &offscl);

      if (offscl)
      {
        return returnValue;
      }
      else
      {
        returnValue = intermediate;
        return returnValue;
      };
    };
  }

  /// @brief Checks for any WCS keywords and processes them as best possible to enable the WCS information to be used to display
  ///        actual RA/DEC rather than (x, y) coordinates.
  /// @throws None.
  /// @version 2013-02-14/GGB - Function created

  void CImageHDB::WCSProcess()
  {
    std::string szctype1;	      /* FITS WCS projection for axis 1 */
    std::string szctype2;	      /* FITS WCS projection for axis 2 */
    char ctype1[255];
    char ctype2[255];
    double crpix1 = 0;	      /* Reference pixel coordinates */
    double crpix2 = 0;	      /* Reference pixel coordinates */
    double crval1 = 0;	      /* Coordinate at reference pixel in degrees */
    double crval2 = 0;	      /* Coordinate at reference pixel in degrees */
    double cd[4] = {0, 0, 0, 0};
    double cdelt1 = 0;	      /* scale in degrees/pixel, if cd is NULL */
    double cdelt2 = 0;	      /* scale in degrees/pixel, if cd is NULL */
    double crota = 0;	        /* Rotation angle in degrees, if cd is NULL */
    int equinox = 0;	        /* Equinox of coordinates, 1950 and 2000 supported */
    double epoch = 0;	        /* Epoch of coordinates, for FK4/FK5 conversion */

    if ( keywordExists(FITS_WCS_CTYPE1) &&
         keywordExists(FITS_WCS_CTYPE2) &&
         keywordExists(FITS_WCS_CRPIX1) &&
         keywordExists(FITS_WCS_CRPIX2) &&
         keywordExists(FITS_WCS_CRVAL1) &&
         keywordExists(FITS_WCS_CRVAL2) )
    {
      szctype1 = static_cast<std::string>(keywordData(FITS_WCS_CTYPE1));
      strncpy(ctype1, szctype1.c_str(), sizeof(ctype1));
      szctype2 = static_cast<std::string>(keywordData(FITS_WCS_CTYPE2));
      strncpy(ctype2, szctype2.c_str(), sizeof(ctype2));
      crpix1 = static_cast<double>(keywordData(FITS_WCS_CRPIX1));
      crpix2 = static_cast<double>(keywordData(FITS_WCS_CRPIX2));
      crval1 = static_cast<double>(keywordData(FITS_WCS_CRVAL1));
      crval2 = static_cast<double>(keywordData(FITS_WCS_CRVAL2));

      if ( keywordExists(FITS_WCS_CD1_1) ||
           keywordExists(FITS_WCS_CD1_2) ||
           keywordExists(FITS_WCS_CD2_1) ||
         keywordExists(FITS_WCS_CD2_2) )
      {
        if (keywordExists(FITS_WCS_CD1_1) )
        {
          cd[0] = static_cast<double>(keywordData(FITS_WCS_CD1_1));
        };
        if (keywordExists(FITS_WCS_CD1_2) )
        {
          cd[1] = static_cast<double>(keywordData(FITS_WCS_CD1_2));
        };
        if (keywordExists(FITS_WCS_CD2_1) )
        {
          cd[2] = static_cast<double>(keywordData(FITS_WCS_CD2_1));
        };
        if (keywordExists(FITS_WCS_CD2_2) )
        {
          cd[3] = static_cast<double>(keywordData(FITS_WCS_CD2_2));
        };

        WCSInformation = wcskinit(NAXISn(1), NAXISn(2), ctype1, ctype2,
                                  crpix1, crpix2, crval1, crval2, cd, cdelt1, cdelt2, crota, equinox, epoch);
      }
      else if ( keywordExists(FITS_WCS_CDELT1) &&
                keywordExists(FITS_WCS_CDELT1) &&
                keywordExists(FITS_WCS_CROTA) )
      {
        cdelt1 = static_cast<double>(keywordData(FITS_WCS_CDELT1));
        cdelt2 = static_cast<double>(keywordData(FITS_WCS_CDELT2));
        crota = static_cast<double>(keywordData(FITS_WCS_CROTA));

        if ( keywordExists(FITS_EPOCH) )
        {
          epoch = static_cast<double>(keywordData(FITS_EPOCH));
        }
        else if ( keywordExists(FITS_EQUINOX) )
        {
          equinox = static_cast<int>(keywordData(FITS_EQUINOX));
        }

        WCSInformation = wcskinit(NAXISn(1), NAXISn(2), ctype1, ctype2,
                                  crpix1, crpix2, crval1, crval2, nullptr, cdelt1, cdelt2, crota, equinox, epoch);
      }
      else
      {
        WCSInformation = nullptr;
      }
    }
    else
    {
      WCSInformation = nullptr;
    }
  }

  /// @brief Determines the initial white point for displaying the image.
  /// @returns The whitepoint value for the image.
  /// @throws CError - ACL::0x1907 - HDB: Data package NULL. Should not be nullptr
  /// @version 2013-07-13/GGB - Added exception if data == nullptr. Return mean + 3 * stdev if no CWHITE keyword.
  /// @version 2012-12-01/GGB - Function created.

  FP_t CImageHDB::whitePoint()
  {
    FP_t wp;

    if (keywordExists(SBIG_CWHITE))
    {
      wp = static_cast<FP_t>(keywordData(SBIG_CWHITE) );

      return wp;
    }
    else if (data)
    {
      FP_t mean = data->getMean();
      FP_t stdev = data->getStDev();

      return ACL::whitePoint(mean, stdev);
    }
    else
    {
      ACL_ERROR(0x1907);  // HDB: Data package NULL. Should not be nullptr
    }
  }

  /// @brief Returns the width of the image.
  /// @returns The width of the image.
  /// 2011-11-27/GGB - Function created.

  AXIS_t CImageHDB::width() const
  {
    if (data)
    {
      return data->width();
    }
    else
    {
      ACL_ERROR(0x2007);    // Data pointer == NULL
    };
  }

  /// @brief Writes the image data to the FITS header that is passed.
  /// @param[in] file - The FITS file.
  /// @throws GCL::CRuntimeAssert
  /// @details A check must be made to see if this object is a primary header or an extended HDU. Mismatches will cause exceptions
  ///          to be generated. This function ensures that the image data is written. The CHDB::CFITS must also be called to
  ///          ensure that all the data is correctly written to disk.
  /// @version 2015-08-13/GGB - Updated to use cfitsio.
  /// @version 2012-01-20/GGB - Function created.

  void CImageHDB::writeToFITS(fitsfile *file)
  {
    RUNTIME_ASSERT(ACL, file != nullptr, "Parameter file cannot be nullptr");
    RUNTIME_ASSERT(ACL, data != nullptr, "Data variable cannot be nullptr");

    int status = 0;
    LONGLONG naxisn[3];

    naxisn[0] = static_cast<LONGLONG>(data->NAXISn(1));
    naxisn[1] = static_cast<LONGLONG>(data->NAXISn(2));
    naxisn[2] = static_cast<LONGLONG>(data->NAXISn(3));

    CFITSIO_TEST(fits_insert_imgll, file, data->BITPIX(), data->NAXIS(), naxisn);

    CHDB::writeToFITS(file);

    data->writeToFITS(file);
  }

  /// @Returns the value of the XTENSION keyword.  If the HDB is a primary header, then an exception is thrown.
  /// @throws 0x1909 - HDB: XTENSION keyword not allowed for PRIMARY header.
  /// @version 2012-01-11/GGB - Function created.

  std::string CImageHDB::XTENSION() const
  {
    if (PRIMARY())
    {
      ACL_ERROR(0x1909);    // HDB: XTENSION keyword not allowed for PRIMARY header.
    }
    else
    {
      return FITS_XTENSION_IMAGE;
    }
  }
}
